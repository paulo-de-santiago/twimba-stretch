var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/hoek/lib/escape.js
var require_escape = __commonJS({
  "../../../node_modules/hoek/lib/escape.js"(exports) {
    "use strict";
    var internals = {};
    exports.escapeJavaScript = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeJavaScriptChar(charCode);
        }
      }
      return escaped;
    };
    exports.escapeHtml = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    exports.escapeJson = function(input) {
      if (!input) {
        return "";
      }
      const lessThan = 60;
      const greaterThan = 62;
      const andSymbol = 38;
      const lineSeperator = 8232;
      let charCode;
      return input.replace(/[<>&\u2028\u2029]/g, (match) => {
        charCode = match.charCodeAt(0);
        if (charCode === lessThan) {
          return "\\u003c";
        } else if (charCode === greaterThan) {
          return "\\u003e";
        } else if (charCode === andSymbol) {
          return "\\u0026";
        } else if (charCode === lineSeperator) {
          return "\\u2028";
        }
        return "\\u2029";
      });
    };
    internals.escapeJavaScriptChar = function(charCode) {
      if (charCode >= 256) {
        return "\\u" + internals.padLeft("" + charCode, 4);
      }
      const hexValue = Buffer.from(String.fromCharCode(charCode), "ascii").toString("hex");
      return "\\x" + internals.padLeft(hexValue, 2);
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml[charCode];
      if (typeof namedEscape !== "undefined") {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = Buffer.from(String.fromCharCode(charCode), "ascii").toString("hex");
      return "&#x" + internals.padLeft(hexValue, 2) + ";";
    };
    internals.padLeft = function(str, len) {
      while (str.length < len) {
        str = "0" + str;
      }
      return str;
    };
    internals.isSafe = function(charCode) {
      return typeof internals.safeCharCodes[charCode] !== "undefined";
    };
    internals.namedHtml = {
      "38": "&amp;",
      "60": "&lt;",
      "62": "&gt;",
      "34": "&quot;",
      "160": "&nbsp;",
      "162": "&cent;",
      "163": "&pound;",
      "164": "&curren;",
      "169": "&copy;",
      "174": "&reg;"
    };
    internals.safeCharCodes = function() {
      const safe = {};
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || // a-z
        i >= 65 && i <= 90 || // A-Z
        i >= 48 && i <= 57 || // 0-9
        i === 32 || // space
        i === 46 || // .
        i === 44 || // ,
        i === 45 || // -
        i === 58 || // :
        i === 95) {
          safe[i] = null;
        }
      }
      return safe;
    }();
  }
});

// ../../../node_modules/hoek/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/hoek/lib/index.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Crypto = require_crypto();
    var Path = require_path();
    var Util = require_util();
    var Escape = require_escape();
    var internals = {};
    exports.clone = function(obj, seen) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      seen = seen || /* @__PURE__ */ new Map();
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
      let newObj;
      let cloneDeep = false;
      if (!Array.isArray(obj)) {
        if (Buffer.isBuffer(obj)) {
          newObj = Buffer.from(obj);
        } else if (obj instanceof Date) {
          newObj = new Date(obj.getTime());
        } else if (obj instanceof RegExp) {
          newObj = new RegExp(obj);
        } else {
          const proto = Object.getPrototypeOf(obj);
          if (proto && proto.isImmutable) {
            newObj = obj;
          } else {
            newObj = Object.create(proto);
            cloneDeep = true;
          }
        }
      } else {
        newObj = [];
        cloneDeep = true;
      }
      seen.set(obj, newObj);
      if (cloneDeep) {
        const keys = Object.getOwnPropertyNames(obj);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          const descriptor = Object.getOwnPropertyDescriptor(obj, key);
          if (descriptor && (descriptor.get || descriptor.set)) {
            Object.defineProperty(newObj, key, descriptor);
          } else {
            newObj[key] = exports.clone(obj[key], seen);
          }
        }
      }
      return newObj;
    };
    exports.merge = function(target, source, isNullOverride, isMergeArrays) {
      exports.assert(target && typeof target === "object", "Invalid target value: must be an object");
      exports.assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      if (Array.isArray(source)) {
        exports.assert(Array.isArray(target), "Cannot merge array onto an object");
        if (isMergeArrays === false) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(exports.clone(source[i]));
        }
        return target;
      }
      const keys = Object.keys(source);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__") {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {
            target[key] = exports.clone(value);
          } else {
            exports.merge(target[key], value, isNullOverride, isMergeArrays);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (isNullOverride !== false) {
            target[key] = value;
          }
        }
      }
      return target;
    };
    exports.applyToDefaults = function(defaults, options, isNullOverride) {
      exports.assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      exports.assert(!options || options === true || typeof options === "object", "Invalid options value: must be true, falsy or an object");
      if (!options) {
        return null;
      }
      const copy = exports.clone(defaults);
      if (options === true) {
        return copy;
      }
      return exports.merge(copy, options, isNullOverride === true, false);
    };
    exports.cloneWithShallow = function(source, keys) {
      if (!source || typeof source !== "object") {
        return source;
      }
      const storage = internals.store(source, keys);
      const copy = exports.clone(source);
      internals.restore(copy, source, storage);
      return copy;
    };
    internals.store = function(source, keys) {
      const storage = {};
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = exports.reach(source, key);
        if (value !== void 0) {
          storage[key] = value;
          internals.reachSet(source, key, void 0);
        }
      }
      return storage;
    };
    internals.restore = function(copy, source, storage) {
      const keys = Object.keys(storage);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        internals.reachSet(copy, key, storage[key]);
        internals.reachSet(source, key, storage[key]);
      }
    };
    internals.reachSet = function(obj, key, value) {
      const path = key.split(".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
          ref[segment] = value;
        }
        ref = ref[segment];
      }
    };
    exports.applyToDefaultsWithShallow = function(defaults, options, keys) {
      exports.assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      exports.assert(!options || options === true || typeof options === "object", "Invalid options value: must be true, falsy or an object");
      exports.assert(keys && Array.isArray(keys), "Invalid keys");
      if (!options) {
        return null;
      }
      const copy = exports.cloneWithShallow(defaults, keys);
      if (options === true) {
        return copy;
      }
      const storage = internals.store(options, keys);
      exports.merge(copy, options, false, false);
      internals.restore(copy, options, storage);
      return copy;
    };
    exports.deepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      options = options || { prototype: true };
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (type !== "object" || obj === null || ref === null) {
        return obj !== obj && ref !== ref;
      }
      seen = seen || [];
      if (seen.indexOf(obj) !== -1) {
        return true;
      }
      seen.push(obj);
      if (Array.isArray(obj)) {
        if (!Array.isArray(ref)) {
          return false;
        }
        if (!options.part && obj.length !== ref.length) {
          return false;
        }
        for (let i = 0; i < obj.length; ++i) {
          if (options.part) {
            let found = false;
            for (let j = 0; j < ref.length; ++j) {
              if (exports.deepEqual(obj[i], ref[j], options)) {
                found = true;
                break;
              }
            }
            return found;
          }
          if (!exports.deepEqual(obj[i], ref[i], options)) {
            return false;
          }
        }
        return true;
      }
      if (Buffer.isBuffer(obj)) {
        if (!Buffer.isBuffer(ref)) {
          return false;
        }
        if (obj.length !== ref.length) {
          return false;
        }
        for (let i = 0; i < obj.length; ++i) {
          if (obj[i] !== ref[i]) {
            return false;
          }
        }
        return true;
      }
      if (obj instanceof Date) {
        return ref instanceof Date && obj.getTime() === ref.getTime();
      }
      if (obj instanceof RegExp) {
        return ref instanceof RegExp && obj.toString() === ref.toString();
      }
      if (options.prototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return false;
        }
      }
      const keys = Object.getOwnPropertyNames(obj);
      if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
        return false;
      }
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.get) {
          if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
            return false;
          }
        } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      return true;
    };
    exports.unique = (array, key) => {
      let result;
      if (key) {
        result = [];
        const index = /* @__PURE__ */ new Set();
        array.forEach((item) => {
          const identifier = item[key];
          if (!index.has(identifier)) {
            index.add(identifier);
            result.push(item);
          }
        });
      } else {
        result = Array.from(new Set(array));
      }
      return result;
    };
    exports.mapToObject = function(array, key) {
      if (!array) {
        return null;
      }
      const obj = {};
      for (let i = 0; i < array.length; ++i) {
        if (key) {
          if (array[i][key]) {
            obj[array[i][key]] = true;
          }
        } else {
          obj[array[i]] = true;
        }
      }
      return obj;
    };
    exports.intersect = function(array1, array2, justFirst) {
      if (!array1 || !array2) {
        return [];
      }
      const common = [];
      const hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;
      const found = {};
      for (let i = 0; i < array2.length; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
          if (justFirst) {
            return array2[i];
          }
          common.push(array2[i]);
          found[array2[i]] = true;
        }
      }
      return justFirst ? null : common;
    };
    exports.contain = function(ref, values, options) {
      let valuePairs = null;
      if (typeof ref === "object" && typeof values === "object" && !Array.isArray(ref) && !Array.isArray(values)) {
        valuePairs = values;
        values = Object.keys(values);
      } else {
        values = [].concat(values);
      }
      options = options || {};
      exports.assert(typeof ref === "string" || typeof ref === "object", "Reference must be string or an object");
      exports.assert(values.length, "Values array cannot be empty");
      let compare;
      let compareFlags;
      if (options.deep) {
        compare = exports.deepEqual;
        const hasOnly = options.hasOwnProperty("only");
        const hasPart = options.hasOwnProperty("part");
        compareFlags = {
          prototype: hasOnly ? options.only : hasPart ? !options.part : false,
          part: hasOnly ? !options.only : hasPart ? options.part : true
        };
      } else {
        compare = (a, b) => a === b;
      }
      let misses = false;
      const matches = new Array(values.length);
      for (let i = 0; i < matches.length; ++i) {
        matches[i] = 0;
      }
      if (typeof ref === "string") {
        let pattern = "(";
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          exports.assert(typeof value === "string", "Cannot compare string reference to non-string value");
          pattern += (i ? "|" : "") + exports.escapeRegex(value);
        }
        const regex = new RegExp(pattern + ")", "g");
        const leftovers = ref.replace(regex, ($0, $1) => {
          const index = values.indexOf($1);
          ++matches[index];
          return "";
        });
        misses = !!leftovers;
      } else if (Array.isArray(ref)) {
        for (let i = 0; i < ref.length; ++i) {
          let matched = false;
          for (let j = 0; j < values.length && matched === false; ++j) {
            matched = compare(values[j], ref[i], compareFlags) && j;
          }
          if (matched !== false) {
            ++matches[matched];
          } else {
            misses = true;
          }
        }
      } else {
        const keys = Object.getOwnPropertyNames(ref);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          const pos = values.indexOf(key);
          if (pos !== -1) {
            if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {
              return false;
            }
            ++matches[pos];
          } else {
            misses = true;
          }
        }
      }
      let result = false;
      for (let i = 0; i < matches.length; ++i) {
        result = result || !!matches[i];
        if (options.once && matches[i] > 1 || !options.part && !matches[i]) {
          return false;
        }
      }
      if (options.only && misses) {
        return false;
      }
      return result;
    };
    exports.flatten = function(array, target) {
      const result = target || [];
      for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
          exports.flatten(array[i], result);
        } else {
          result.push(array[i]);
        }
      }
      return result;
    };
    exports.reach = function(obj, chain, options) {
      if (chain === false || chain === null || typeof chain === "undefined") {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const path = chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        if (key[0] === "-" && Array.isArray(ref)) {
          key = key.slice(1, key.length);
          key = ref.length - key;
        }
        if (!ref || !((typeof ref === "object" || typeof ref === "function") && key in ref) || typeof ref !== "object" && options.functions === false) {
          exports.assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          exports.assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        ref = ref[key];
      }
      return ref;
    };
    exports.reachTemplate = function(obj, template, options) {
      return template.replace(/{([^}]+)}/g, ($0, chain) => {
        const value = exports.reach(obj, chain, options);
        return value === void 0 || value === null ? "" : value;
      });
    };
    exports.formatStack = function(stack) {
      const trace = [];
      for (let i = 0; i < stack.length; ++i) {
        const item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
      }
      return trace;
    };
    exports.formatTrace = function(trace) {
      const display = [];
      for (let i = 0; i < trace.length; ++i) {
        const row = trace[i];
        display.push((row[4] ? "new " : "") + row[3] + " (" + row[0] + ":" + row[1] + ":" + row[2] + ")");
      }
      return display;
    };
    exports.callStack = function(slice) {
      const v8 = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      const capture = {};
      Error.captureStackTrace(capture, this);
      const stack = capture.stack;
      Error.prepareStackTrace = v8;
      const trace = exports.formatStack(stack);
      return trace.slice(1 + slice);
    };
    exports.displayStack = function(slice) {
      const trace = exports.callStack(slice === void 0 ? 1 : slice + 1);
      return exports.formatTrace(trace);
    };
    exports.abortThrow = false;
    exports.abort = function(message, hideStack) {
      if (exports.abortThrow === true) {
        throw new Error(message || "Unknown error");
      }
      let stack = "";
      if (!hideStack) {
        stack = exports.displayStack(1).join("\n	");
      }
      console.log("ABORT: " + message + "\n	" + stack);
      process.exit(1);
    };
    exports.assert = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);
      });
      throw new Assert.AssertionError({
        message: msgs.join(" ") || "Unknown error",
        actual: false,
        expected: true,
        operator: "==",
        stackStartFunction: exports.assert
      });
    };
    exports.Bench = function() {
      this.ts = 0;
      this.reset();
    };
    exports.Bench.prototype.reset = function() {
      this.ts = exports.Bench.now();
    };
    exports.Bench.prototype.elapsed = function() {
      return exports.Bench.now() - this.ts;
    };
    exports.Bench.now = function() {
      const ts = process.hrtime();
      return ts[0] * 1e3 + ts[1] / 1e6;
    };
    exports.escapeRegex = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
    exports.base64urlEncode = function(value, encoding) {
      exports.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
      const buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
      return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    };
    exports.base64urlDecode = function(value, encoding) {
      if (typeof value !== "string") {
        throw new Error("Value not a string");
      }
      if (!/^[\w\-]*$/.test(value)) {
        throw new Error("Invalid character");
      }
      const buf = Buffer.from(value, "base64");
      return encoding === "buffer" ? buf : buf.toString(encoding || "binary");
    };
    exports.escapeHeaderAttribute = function(attribute) {
      exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
    exports.escapeHtml = function(string) {
      return Escape.escapeHtml(string);
    };
    exports.escapeJavaScript = function(string) {
      return Escape.escapeJavaScript(string);
    };
    exports.escapeJson = function(string) {
      return Escape.escapeJson(string);
    };
    exports.once = function(method) {
      if (method._hoekOnce) {
        return method;
      }
      let once = false;
      const wrapped = function(...args) {
        if (!once) {
          once = true;
          method.apply(null, args);
        }
      };
      wrapped._hoekOnce = true;
      return wrapped;
    };
    exports.isInteger = Number.isSafeInteger;
    exports.ignore = function() {
    };
    exports.inherits = Util.inherits;
    exports.format = Util.format;
    exports.transform = function(source, transform, options) {
      exports.assert(source === null || source === void 0 || typeof source === "object" || Array.isArray(source), "Invalid source object: must be null, undefined, an object, or an array");
      const separator = typeof options === "object" && options !== null ? options.separator || "." : ".";
      if (Array.isArray(source)) {
        const results = [];
        for (let i = 0; i < source.length; ++i) {
          results.push(exports.transform(source[i], transform, options));
        }
        return results;
      }
      const result = {};
      const keys = Object.keys(transform);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const path = key.split(separator);
        const sourcePath = transform[key];
        exports.assert(typeof sourcePath === "string", 'All mappings must be "." delineated strings');
        let segment;
        let res = result;
        while (path.length > 1) {
          segment = path.shift();
          if (!res[segment]) {
            res[segment] = {};
          }
          res = res[segment];
        }
        segment = path.shift();
        res[segment] = exports.reach(source, sourcePath, options);
      }
      return result;
    };
    exports.uniqueFilename = function(path, extension) {
      if (extension) {
        extension = extension[0] !== "." ? "." + extension : extension;
      } else {
        extension = "";
      }
      path = Path.resolve(path);
      const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
      return Path.join(path, name);
    };
    exports.stringify = function(...args) {
      try {
        return JSON.stringify.apply(null, args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
    exports.shallow = function(source) {
      return Object.assign({}, source);
    };
    exports.wait = function(timeout) {
      return new Promise((resolve) => setTimeout(resolve, timeout));
    };
    exports.block = function() {
      return new Promise(exports.ignore);
    };
  }
});

// ../../../node_modules/joi/lib/ref.js
var require_ref = __commonJS({
  "../../../node_modules/joi/lib/ref.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    exports.create = function(key, options) {
      Hoek.assert(typeof key === "string", "Invalid reference key:", key);
      const settings = Hoek.clone(options);
      const ref = function(value, validationOptions) {
        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
      };
      ref.isContext = key[0] === (settings && settings.contextPrefix || "$");
      ref.key = ref.isContext ? key.slice(1) : key;
      ref.path = ref.key.split(settings && settings.separator || ".");
      ref.depth = ref.path.length;
      ref.root = ref.path[0];
      ref.isJoi = true;
      ref.toString = function() {
        return (ref.isContext ? "context:" : "ref:") + ref.key;
      };
      return ref;
    };
    exports.isRef = function(ref) {
      return typeof ref === "function" && ref.isJoi;
    };
    exports.push = function(array, ref) {
      if (exports.isRef(ref) && !ref.isContext) {
        array.push(ref.root);
      }
    };
  }
});

// ../../../node_modules/joi/lib/language.js
var require_language = __commonJS({
  "../../../node_modules/joi/lib/language.js"(exports) {
    "use strict";
    exports.errors = {
      root: "value",
      key: '"{{!label}}" ',
      messages: {
        wrapArrays: true
      },
      any: {
        unknown: "is not allowed",
        invalid: "contains an invalid value",
        empty: "is not allowed to be empty",
        required: "is required",
        allowOnly: "must be one of {{valids}}",
        default: "threw an error when running default method"
      },
      alternatives: {
        base: "not matching any of the allowed alternatives",
        child: null
      },
      array: {
        base: "must be an array",
        includes: "at position {{pos}} does not match any of the allowed types",
        includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
        includesOne: "at position {{pos}} fails because {{reason}}",
        includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
        includesRequiredUnknowns: "does not contain {{unknownMisses}} required value(s)",
        includesRequiredKnowns: "does not contain {{knownMisses}}",
        includesRequiredBoth: "does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)",
        excludes: "at position {{pos}} contains an excluded value",
        excludesSingle: 'single value of "{{!label}}" contains an excluded value',
        min: "must contain at least {{limit}} items",
        max: "must contain less than or equal to {{limit}} items",
        length: "must contain {{limit}} items",
        ordered: "at position {{pos}} fails because {{reason}}",
        orderedLength: "at position {{pos}} fails because array must contain at most {{limit}} items",
        ref: 'references "{{ref}}" which is not a positive integer',
        sparse: "must not be a sparse array",
        unique: "position {{pos}} contains a duplicate value"
      },
      boolean: {
        base: "must be a boolean"
      },
      binary: {
        base: "must be a buffer or a string",
        min: "must be at least {{limit}} bytes",
        max: "must be less than or equal to {{limit}} bytes",
        length: "must be {{limit}} bytes"
      },
      date: {
        base: "must be a number of milliseconds or valid date string",
        format: "must be a string with one of the following formats {{format}}",
        strict: "must be a valid date",
        min: 'must be larger than or equal to "{{limit}}"',
        max: 'must be less than or equal to "{{limit}}"',
        isoDate: "must be a valid ISO 8601 date",
        timestamp: {
          javascript: "must be a valid timestamp or number of milliseconds",
          unix: "must be a valid timestamp or number of seconds"
        },
        ref: 'references "{{ref}}" which is not a date'
      },
      function: {
        base: "must be a Function",
        arity: "must have an arity of {{n}}",
        minArity: "must have an arity greater or equal to {{n}}",
        maxArity: "must have an arity lesser or equal to {{n}}",
        ref: "must be a Joi reference",
        class: "must be a class"
      },
      lazy: {
        base: "!!schema error: lazy schema must be set",
        schema: "!!schema error: lazy schema function must return a schema"
      },
      object: {
        base: "must be an object",
        child: '!!child "{{!child}}" fails because {{reason}}',
        min: "must have at least {{limit}} children",
        max: "must have less than or equal to {{limit}} children",
        length: "must have {{limit}} children",
        allowUnknown: '!!"{{!child}}" is not allowed',
        with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
        without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
        missing: "must contain at least one of {{peersWithLabels}}",
        xor: "contains a conflict between exclusive peers {{peersWithLabels}}",
        or: "must contain at least one of {{peersWithLabels}}",
        and: "contains {{presentWithLabels}} without its required peers {{missingWithLabels}}",
        nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
        assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
        rename: {
          multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
          override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
          regex: {
            multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
            override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
          }
        },
        type: 'must be an instance of "{{type}}"',
        schema: "must be a Joi instance"
      },
      number: {
        base: "must be a number",
        min: "must be larger than or equal to {{limit}}",
        max: "must be less than or equal to {{limit}}",
        less: "must be less than {{limit}}",
        greater: "must be greater than {{limit}}",
        float: "must be a float or double",
        integer: "must be an integer",
        negative: "must be a negative number",
        positive: "must be a positive number",
        precision: "must have no more than {{limit}} decimal places",
        ref: 'references "{{ref}}" which is not a number',
        multiple: "must be a multiple of {{multiple}}"
      },
      string: {
        base: "must be a string",
        min: "length must be at least {{limit}} characters long",
        max: "length must be less than or equal to {{limit}} characters long",
        length: "length must be {{limit}} characters long",
        alphanum: "must only contain alpha-numeric characters",
        token: "must only contain alpha-numeric and underscore characters",
        regex: {
          base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
          name: 'with value "{{!value}}" fails to match the {{name}} pattern',
          invert: {
            base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
            name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
          }
        },
        email: "must be a valid email",
        uri: "must be a valid uri",
        uriRelativeOnly: "must be a valid relative uri",
        uriCustomScheme: "must be a valid uri with a scheme matching the {{scheme}} pattern",
        isoDate: "must be a valid ISO 8601 date",
        guid: "must be a valid GUID",
        hex: "must only contain hexadecimal characters",
        base64: "must be a valid base64 string",
        hostname: "must be a valid hostname",
        normalize: "must be unicode normalized in the {{form}} form",
        lowercase: "must only contain lowercase characters",
        uppercase: "must only contain uppercase characters",
        trim: "must not have leading or trailing whitespace",
        creditCard: "must be a credit card",
        ref: 'references "{{ref}}" which is not a number',
        ip: "must be a valid ip address with a {{cidr}} CIDR",
        ipVersion: "must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR"
      }
    };
  }
});

// ../../../node_modules/joi/lib/errors.js
var require_errors = __commonJS({
  "../../../node_modules/joi/lib/errors.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Language = require_language();
    var internals = {
      annotations: Symbol("joi-annotations")
    };
    internals.stringify = function(value, wrapArrays) {
      const type = typeof value;
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return value;
      }
      if (value instanceof exports.Err || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type === "object") {
        if (Array.isArray(value)) {
          let partial = "";
          for (let i = 0; i < value.length; ++i) {
            partial = partial + (partial.length ? ", " : "") + internals.stringify(value[i], wrapArrays);
          }
          return wrapArrays ? "[" + partial + "]" : partial;
        }
        return value.toString();
      }
      return JSON.stringify(value);
    };
    exports.Err = class {
      constructor(type, context, state, options, flags, message, template) {
        this.isJoi = true;
        this.type = type;
        this.context = context || {};
        this.context.key = state.path[state.path.length - 1];
        this.context.label = state.key;
        this.path = state.path;
        this.options = options;
        this.flags = flags;
        this.message = message;
        this.template = template;
        const localized = this.options.language;
        if (this.flags.label) {
          this.context.label = this.flags.label;
        } else if (localized && // language can be null for arrays exclusion check
        (this.context.label === "" || this.context.label === null)) {
          this.context.label = localized.root || Language.errors.root;
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        let format;
        if (this.template) {
          format = this.template;
        }
        const localized = this.options.language;
        format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
        if (format === void 0) {
          return `Error code "${this.type}" is not defined, your custom type is missing the correct language definition`;
        }
        let wrapArrays = Hoek.reach(localized, "messages.wrapArrays");
        if (typeof wrapArrays !== "boolean") {
          wrapArrays = Language.errors.messages.wrapArrays;
        }
        if (format === null) {
          const childrenString = internals.stringify(this.context.reason, wrapArrays);
          if (wrapArrays) {
            return childrenString.slice(1, -1);
          }
          return childrenString;
        }
        const hasKey = /\{\{\!?label\}\}/.test(format);
        const skipKey = format.length > 2 && format[0] === "!" && format[1] === "!";
        if (skipKey) {
          format = format.slice(2);
        }
        if (!hasKey && !skipKey) {
          const localizedKey = Hoek.reach(localized, "key");
          if (typeof localizedKey === "string") {
            format = localizedKey + format;
          } else {
            format = Hoek.reach(Language.errors, "key") + format;
          }
        }
        return format.replace(/\{\{(\!?)([^}]+)\}\}/g, ($0, isSecure, name) => {
          const value = Hoek.reach(this.context, name);
          const normalized = internals.stringify(value, wrapArrays);
          return isSecure && this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized;
        });
      }
    };
    exports.create = function(type, context, state, options, flags, message, template) {
      return new exports.Err(type, context, state, options, flags, message, template);
    };
    exports.process = function(errors2, object) {
      if (!errors2 || !errors2.length) {
        return null;
      }
      let message = "";
      const details = [];
      const processErrors = function(localErrors, parent) {
        for (let i = 0; i < localErrors.length; ++i) {
          const item = localErrors[i];
          if (item instanceof Error) {
            return item;
          }
          if (item.flags.error && typeof item.flags.error !== "function") {
            return item.flags.error;
          }
          let itemMessage;
          if (parent === void 0) {
            itemMessage = item.toString();
            message = message + (message ? ". " : "") + itemMessage;
          }
          if (item.context.reason && item.context.reason.length) {
            const override2 = processErrors(item.context.reason, item.path);
            if (override2) {
              return override2;
            }
          } else {
            details.push({
              message: itemMessage || item.toString(),
              path: item.path,
              type: item.type,
              context: item.context
            });
          }
        }
      };
      const override = processErrors(errors2);
      if (override) {
        return override;
      }
      const error2 = new Error(message);
      error2.isJoi = true;
      error2.name = "ValidationError";
      error2.details = details;
      error2._object = object;
      error2.annotate = internals.annotate;
      return error2;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              const errorKeys = Object.keys(annotations.errors);
              for (let i = 0; i < errorKeys.length; ++i) {
                const errorKey = errorKeys[i];
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              const missingKeys = Object.keys(annotations.missing);
              for (let i = 0; i < missingKeys.length; ++i) {
                const missingKey = missingKeys[i];
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
    internals.annotate = function(stripColorCodes) {
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      if (typeof this._object !== "object") {
        return this.details[0].message;
      }
      const obj = Hoek.clone(this._object || {});
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error2 = this.details[i];
        const path = error2.path;
        let ref = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (ref.isImmutable) {
            ref = ref.clone();
          }
          if (j + 1 < path.length && ref[seg] && typeof ref[seg] !== "string") {
            ref = ref[seg];
          } else {
            const refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
            const value = ref[seg];
            const cacheKey = seg || error2.context.label;
            if (value !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_\"/g,
        missing: /\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g,
        arrayIndex: /\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)\]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
  }
});

// ../../../node_modules/joi/lib/set.js
var require_set = __commonJS({
  "../../../node_modules/joi/lib/set.js"(exports, module) {
    "use strict";
    var Ref = require_ref();
    module.exports = class Set2 {
      constructor() {
        this._set = [];
      }
      add(value, refs) {
        if (!Ref.isRef(value) && this.has(value, null, null, false)) {
          return;
        }
        if (refs !== void 0) {
          Ref.push(refs, value);
        }
        this._set.push(value);
        return this;
      }
      merge(add, remove) {
        for (let i = 0; i < add._set.length; ++i) {
          this.add(add._set[i]);
        }
        for (let i = 0; i < remove._set.length; ++i) {
          this.remove(remove._set[i]);
        }
        return this;
      }
      remove(value) {
        this._set = this._set.filter((item) => value !== item);
        return this;
      }
      has(value, state, options, insensitive) {
        for (let i = 0; i < this._set.length; ++i) {
          let items = this._set[i];
          if (state && Ref.isRef(items)) {
            items = items(state.reference || state.parent, options);
          }
          if (!Array.isArray(items)) {
            items = [items];
          }
          for (let j = 0; j < items.length; ++j) {
            const item = items[j];
            if (typeof value !== typeof item) {
              continue;
            }
            if (value === item || value instanceof Date && item instanceof Date && value.getTime() === item.getTime() || insensitive && typeof value === "string" && value.toLowerCase() === item.toLowerCase() || Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString("binary") === item.toString("binary")) {
              return true;
            }
          }
        }
        return false;
      }
      values(options) {
        if (options && options.stripUndefined) {
          const values = [];
          for (let i = 0; i < this._set.length; ++i) {
            const item = this._set[i];
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return this._set.slice();
      }
      slice() {
        const newSet = new Set2();
        newSet._set = this._set.slice();
        return newSet;
      }
      concat(source) {
        const newSet = new Set2();
        newSet._set = this._set.concat(source._set);
        return newSet;
      }
    };
  }
});

// ../../../node_modules/joi/lib/cast.js
var require_cast = __commonJS({
  "../../../node_modules/joi/lib/cast.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Ref = require_ref();
    exports.schema = function(Joi, config) {
      if (config !== void 0 && config !== null && typeof config === "object") {
        if (config.isJoi) {
          return config;
        }
        if (Array.isArray(config)) {
          return Joi.alternatives().try(config);
        }
        if (config instanceof RegExp) {
          return Joi.string().regex(config);
        }
        if (config instanceof Date) {
          return Joi.date().valid(config);
        }
        return Joi.object().keys(config);
      }
      if (typeof config === "string") {
        return Joi.string().valid(config);
      }
      if (typeof config === "number") {
        return Joi.number().valid(config);
      }
      if (typeof config === "boolean") {
        return Joi.boolean().valid(config);
      }
      if (Ref.isRef(config)) {
        return Joi.valid(config);
      }
      Hoek.assert(config === null, "Invalid schema content:", config);
      return Joi.valid(null);
    };
    exports.ref = function(id) {
      return Ref.isRef(id) ? id : Ref.create(id);
    };
  }
});

// ../../../node_modules/joi/lib/types/lazy/index.js
var require_lazy = __commonJS({
  "../../../node_modules/joi/lib/types/lazy/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Hoek = require_lib();
    var internals = {};
    internals.Lazy = class extends Any {
      constructor() {
        super();
        this._type = "lazy";
      }
      _base(value, state, options) {
        const result = { value };
        const lazy = this._flags.lazy;
        if (!lazy) {
          result.errors = this.createError("lazy.base", null, state, options);
          return result;
        }
        const schema = lazy();
        if (!(schema instanceof Any)) {
          result.errors = this.createError("lazy.schema", null, state, options);
          return result;
        }
        return schema._validate(value, state, options);
      }
      set(fn) {
        Hoek.assert(typeof fn === "function", "You must provide a function as first argument");
        const obj = this.clone();
        obj._flags.lazy = fn;
        return obj;
      }
    };
    module.exports = new internals.Lazy();
  }
});

// ../../../node_modules/joi/lib/types/array/index.js
var require_array = __commonJS({
  "../../../node_modules/joi/lib/types/array/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Cast = require_cast();
    var Ref = require_ref();
    var Hoek = require_lib();
    var internals = {};
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.Array = class extends Any {
      constructor() {
        super();
        this._type = "array";
        this._inner.items = [];
        this._inner.ordereds = [];
        this._inner.inclusions = [];
        this._inner.exclusions = [];
        this._inner.requireds = [];
        this._flags.sparse = false;
      }
      _base(value, state, options) {
        const result = {
          value
        };
        if (typeof value === "string" && options.convert) {
          internals.safeParse(value, result);
        }
        let isArray = Array.isArray(result.value);
        const wasArray = isArray;
        if (options.convert && this._flags.single && !isArray) {
          result.value = [result.value];
          isArray = true;
        }
        if (!isArray) {
          result.errors = this.createError("array.base", null, state, options);
          return result;
        }
        if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {
          if (wasArray) {
            result.value = result.value.slice(0);
          }
          result.errors = this._checkItems.call(this, result.value, wasArray, state, options);
          if (result.errors && wasArray && options.convert && this._flags.single) {
            const previousErrors = result.errors;
            result.value = [result.value];
            result.errors = this._checkItems.call(this, result.value, wasArray, state, options);
            if (result.errors) {
              result.errors = previousErrors;
              result.value = result.value[0];
            }
          }
        }
        return result;
      }
      _checkItems(items, wasArray, state, options) {
        const errors2 = [];
        let errored;
        const requireds = this._inner.requireds.slice();
        const ordereds = this._inner.ordereds.slice();
        const inclusions = this._inner.inclusions.concat(requireds);
        let il = items.length;
        for (let i = 0; i < il; ++i) {
          errored = false;
          const item = items[i];
          let isValid = false;
          const key = wasArray ? i : state.key;
          const path = wasArray ? state.path.concat(i) : state.path;
          const localState = { key, path, parent: state.parent, reference: state.reference };
          let res;
          if (!this._flags.sparse && item === void 0) {
            errors2.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
            if (options.abortEarly) {
              return errors2;
            }
            continue;
          }
          for (let j = 0; j < this._inner.exclusions.length; ++j) {
            res = this._inner.exclusions[j]._validate(item, localState, {});
            if (!res.errors) {
              errors2.push(this.createError(wasArray ? "array.excludes" : "array.excludesSingle", { pos: i, value: item }, { key: state.key, path: localState.path }, options));
              errored = true;
              if (options.abortEarly) {
                return errors2;
              }
              break;
            }
          }
          if (errored) {
            continue;
          }
          if (this._inner.ordereds.length) {
            if (ordereds.length > 0) {
              const ordered = ordereds.shift();
              res = ordered._validate(item, localState, options);
              if (!res.errors) {
                if (ordered._flags.strip) {
                  internals.fastSplice(items, i);
                  --i;
                  --il;
                } else if (!this._flags.sparse && res.value === void 0) {
                  errors2.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                  if (options.abortEarly) {
                    return errors2;
                  }
                  continue;
                } else {
                  items[i] = res.value;
                }
              } else {
                errors2.push(this.createError("array.ordered", { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                if (options.abortEarly) {
                  return errors2;
                }
              }
              continue;
            } else if (!this._inner.items.length) {
              errors2.push(this.createError("array.orderedLength", { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
              if (options.abortEarly) {
                return errors2;
              }
              continue;
            }
          }
          const requiredChecks = [];
          let jl = requireds.length;
          for (let j = 0; j < jl; ++j) {
            res = requiredChecks[j] = requireds[j]._validate(item, localState, options);
            if (!res.errors) {
              items[i] = res.value;
              isValid = true;
              internals.fastSplice(requireds, j);
              --j;
              --jl;
              if (!this._flags.sparse && res.value === void 0) {
                errors2.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                if (options.abortEarly) {
                  return errors2;
                }
              }
              break;
            }
          }
          if (isValid) {
            continue;
          }
          const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.arrays : false;
          jl = inclusions.length;
          for (let j = 0; j < jl; ++j) {
            const inclusion = inclusions[j];
            const previousCheck = requireds.indexOf(inclusion);
            if (previousCheck !== -1) {
              res = requiredChecks[previousCheck];
            } else {
              res = inclusion._validate(item, localState, options);
              if (!res.errors) {
                if (inclusion._flags.strip) {
                  internals.fastSplice(items, i);
                  --i;
                  --il;
                } else if (!this._flags.sparse && res.value === void 0) {
                  errors2.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                  errored = true;
                } else {
                  items[i] = res.value;
                }
                isValid = true;
                break;
              }
            }
            if (jl === 1) {
              if (stripUnknown) {
                internals.fastSplice(items, i);
                --i;
                --il;
                isValid = true;
                break;
              }
              errors2.push(this.createError(wasArray ? "array.includesOne" : "array.includesOneSingle", { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
              errored = true;
              if (options.abortEarly) {
                return errors2;
              }
              break;
            }
          }
          if (errored) {
            continue;
          }
          if (this._inner.inclusions.length && !isValid) {
            if (stripUnknown) {
              internals.fastSplice(items, i);
              --i;
              --il;
              continue;
            }
            errors2.push(this.createError(wasArray ? "array.includes" : "array.includesSingle", { pos: i, value: item }, { key: state.key, path: localState.path }, options));
            if (options.abortEarly) {
              return errors2;
            }
          }
        }
        if (requireds.length) {
          this._fillMissedErrors.call(this, errors2, requireds, state, options);
        }
        if (ordereds.length) {
          this._fillOrderedErrors.call(this, errors2, ordereds, state, options);
        }
        return errors2.length ? errors2 : null;
      }
      describe() {
        const description = Any.prototype.describe.call(this);
        if (this._inner.ordereds.length) {
          description.orderedItems = [];
          for (let i = 0; i < this._inner.ordereds.length; ++i) {
            description.orderedItems.push(this._inner.ordereds[i].describe());
          }
        }
        if (this._inner.items.length) {
          description.items = [];
          for (let i = 0; i < this._inner.items.length; ++i) {
            description.items.push(this._inner.items[i].describe());
          }
        }
        return description;
      }
      items(...schemas) {
        const obj = this.clone();
        Hoek.flatten(schemas).forEach((type, index) => {
          try {
            type = Cast.schema(this._currentJoi, type);
          } catch (castErr) {
            if (castErr.hasOwnProperty("path")) {
              castErr.path = index + "." + castErr.path;
            } else {
              castErr.path = index;
            }
            castErr.message = castErr.message + "(" + castErr.path + ")";
            throw castErr;
          }
          obj._inner.items.push(type);
          if (type._flags.presence === "required") {
            obj._inner.requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            obj._inner.exclusions.push(type.optional());
          } else {
            obj._inner.inclusions.push(type);
          }
        });
        return obj;
      }
      ordered(...schemas) {
        const obj = this.clone();
        Hoek.flatten(schemas).forEach((type, index) => {
          try {
            type = Cast.schema(this._currentJoi, type);
          } catch (castErr) {
            if (castErr.hasOwnProperty("path")) {
              castErr.path = index + "." + castErr.path;
            } else {
              castErr.path = index;
            }
            castErr.message = castErr.message + "(" + castErr.path + ")";
            throw castErr;
          }
          obj._inner.ordereds.push(type);
        });
        return obj;
      }
      min(limit) {
        const isRef = Ref.isRef(limit);
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
        return this._test("min", limit, function(value, state, options) {
          let compareTo;
          if (isRef) {
            compareTo = limit(state.reference || state.parent, options);
            if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
              return this.createError("array.ref", { ref: limit.key }, state, options);
            }
          } else {
            compareTo = limit;
          }
          if (value.length >= compareTo) {
            return value;
          }
          return this.createError("array.min", { limit, value }, state, options);
        });
      }
      max(limit) {
        const isRef = Ref.isRef(limit);
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
        return this._test("max", limit, function(value, state, options) {
          let compareTo;
          if (isRef) {
            compareTo = limit(state.reference || state.parent, options);
            if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
              return this.createError("array.ref", { ref: limit.key }, state, options);
            }
          } else {
            compareTo = limit;
          }
          if (value.length <= compareTo) {
            return value;
          }
          return this.createError("array.max", { limit, value }, state, options);
        });
      }
      length(limit) {
        const isRef = Ref.isRef(limit);
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
        return this._test("length", limit, function(value, state, options) {
          let compareTo;
          if (isRef) {
            compareTo = limit(state.reference || state.parent, options);
            if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
              return this.createError("array.ref", { ref: limit.key }, state, options);
            }
          } else {
            compareTo = limit;
          }
          if (value.length === compareTo) {
            return value;
          }
          return this.createError("array.length", { limit, value }, state, options);
        });
      }
      unique(comparator) {
        Hoek.assert(comparator === void 0 || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
        const settings = {};
        if (typeof comparator === "string") {
          settings.path = comparator;
        } else if (typeof comparator === "function") {
          settings.comparator = comparator;
        }
        return this._test("unique", settings, function(value, state, options) {
          const found = {
            string: {},
            number: {},
            undefined: {},
            boolean: {},
            object: /* @__PURE__ */ new Map(),
            function: /* @__PURE__ */ new Map(),
            custom: /* @__PURE__ */ new Map()
          };
          const compare = settings.comparator || Hoek.deepEqual;
          for (let i = 0; i < value.length; ++i) {
            const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
            const records = settings.comparator ? found.custom : found[typeof item];
            if (
              /* $lab:coverage:off$ */
              records
            ) {
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = {
                      key: state.key,
                      path: state.path.concat(i),
                      parent: state.parent,
                      reference: state.reference
                    };
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (settings.path) {
                      context.path = settings.path;
                    }
                    return this.createError("array.unique", context, localState, options);
                  }
                }
                records.set(item, i);
              } else {
                if (records[item] !== void 0) {
                  const localState = {
                    key: state.key,
                    path: state.path.concat(i),
                    parent: state.parent,
                    reference: state.reference
                  };
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (settings.path) {
                    context.path = settings.path;
                  }
                  return this.createError("array.unique", context, localState, options);
                }
                records[item] = i;
              }
            }
          }
          return value;
        });
      }
      sparse(enabled) {
        const value = enabled === void 0 ? true : !!enabled;
        if (this._flags.sparse === value) {
          return this;
        }
        const obj = this.clone();
        obj._flags.sparse = value;
        return obj;
      }
      single(enabled) {
        const value = enabled === void 0 ? true : !!enabled;
        if (this._flags.single === value) {
          return this;
        }
        const obj = this.clone();
        obj._flags.single = value;
        return obj;
      }
      _fillMissedErrors(errors2, requireds, state, options) {
        const knownMisses = [];
        let unknownMisses = 0;
        for (let i = 0; i < requireds.length; ++i) {
          const label = requireds[i]._getLabel();
          if (label) {
            knownMisses.push(label);
          } else {
            ++unknownMisses;
          }
        }
        if (knownMisses.length) {
          if (unknownMisses) {
            errors2.push(this.createError("array.includesRequiredBoth", { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));
          } else {
            errors2.push(this.createError("array.includesRequiredKnowns", { knownMisses }, { key: state.key, path: state.path }, options));
          }
        } else {
          errors2.push(this.createError("array.includesRequiredUnknowns", { unknownMisses }, { key: state.key, path: state.path }, options));
        }
      }
      _fillOrderedErrors(errors2, ordereds, state, options) {
        const requiredOrdereds = [];
        for (let i = 0; i < ordereds.length; ++i) {
          const presence = Hoek.reach(ordereds[i], "_flags.presence");
          if (presence === "required") {
            requiredOrdereds.push(ordereds[i]);
          }
        }
        if (requiredOrdereds.length) {
          this._fillMissedErrors.call(this, errors2, requiredOrdereds, state, options);
        }
      }
    };
    internals.safeParse = function(value, result) {
      try {
        const converted = JSON.parse(value);
        if (Array.isArray(converted)) {
          result.value = converted;
        }
      } catch (e) {
      }
    };
    module.exports = new internals.Array();
  }
});

// ../../../node_modules/joi/lib/types/boolean/index.js
var require_boolean = __commonJS({
  "../../../node_modules/joi/lib/types/boolean/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Hoek = require_lib();
    var internals = {
      Set: require_set()
    };
    internals.Boolean = class extends Any {
      constructor() {
        super();
        this._type = "boolean";
        this._flags.insensitive = true;
        this._inner.truthySet = new internals.Set();
        this._inner.falsySet = new internals.Set();
      }
      _base(value, state, options) {
        const result = {
          value
        };
        if (typeof value === "string" && options.convert) {
          const normalized = this._flags.insensitive ? value.toLowerCase() : value;
          result.value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof result.value !== "boolean") {
          result.value = this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true : this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value;
        }
        result.errors = typeof result.value === "boolean" ? null : this.createError("boolean.base", null, state, options);
        return result;
      }
      truthy(...values) {
        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          Hoek.assert(value !== void 0, "Cannot call truthy with undefined");
          obj._inner.truthySet.add(value);
        }
        return obj;
      }
      falsy(...values) {
        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          Hoek.assert(value !== void 0, "Cannot call falsy with undefined");
          obj._inner.falsySet.add(value);
        }
        return obj;
      }
      insensitive(enabled) {
        const insensitive = enabled === void 0 ? true : !!enabled;
        if (this._flags.insensitive === insensitive) {
          return this;
        }
        const obj = this.clone();
        obj._flags.insensitive = insensitive;
        return obj;
      }
      describe() {
        const description = Any.prototype.describe.call(this);
        description.truthy = [true].concat(this._inner.truthySet.values());
        description.falsy = [false].concat(this._inner.falsySet.values());
        return description;
      }
    };
    module.exports = new internals.Boolean();
  }
});

// ../../../node_modules/joi/lib/types/binary/index.js
var require_binary = __commonJS({
  "../../../node_modules/joi/lib/types/binary/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Hoek = require_lib();
    var internals = {};
    internals.Binary = class extends Any {
      constructor() {
        super();
        this._type = "binary";
      }
      _base(value, state, options) {
        const result = {
          value
        };
        if (typeof value === "string" && options.convert) {
          try {
            result.value = new Buffer(value, this._flags.encoding);
          } catch (e) {
          }
        }
        result.errors = Buffer.isBuffer(result.value) ? null : this.createError("binary.base", null, state, options);
        return result;
      }
      encoding(encoding) {
        Hoek.assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
        if (this._flags.encoding === encoding) {
          return this;
        }
        const obj = this.clone();
        obj._flags.encoding = encoding;
        return obj;
      }
      min(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("min", limit, function(value, state, options) {
          if (value.length >= limit) {
            return value;
          }
          return this.createError("binary.min", { limit, value }, state, options);
        });
      }
      max(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("max", limit, function(value, state, options) {
          if (value.length <= limit) {
            return value;
          }
          return this.createError("binary.max", { limit, value }, state, options);
        });
      }
      length(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("length", limit, function(value, state, options) {
          if (value.length === limit) {
            return value;
          }
          return this.createError("binary.length", { limit, value }, state, options);
        });
      }
    };
    module.exports = new internals.Binary();
  }
});

// ../../../node_modules/joi/lib/types/date/index.js
var require_date = __commonJS({
  "../../../node_modules/joi/lib/types/date/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Ref = require_ref();
    var Hoek = require_lib();
    var internals = {};
    internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
    internals.invalidDate = /* @__PURE__ */ new Date("");
    internals.isIsoDate = (() => {
      const isoString = internals.isoDate.toString();
      return (date) => {
        return date && date.toString() === isoString;
      };
    })();
    internals.Date = class extends Any {
      constructor() {
        super();
        this._type = "date";
      }
      _base(value, state, options) {
        const result = {
          value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value
        };
        if (result.value instanceof Date && !isNaN(result.value.getTime())) {
          result.errors = null;
        } else if (!options.convert) {
          result.errors = this.createError("date.strict", null, state, options);
        } else {
          let type;
          if (internals.isIsoDate(this._flags.format)) {
            type = "isoDate";
          } else if (this._flags.timestamp) {
            type = `timestamp.${this._flags.timestamp}`;
          } else {
            type = "base";
          }
          result.errors = this.createError(`date.${type}`, null, state, options);
        }
        return result;
      }
      static toDate(value, format, timestamp, multiplier) {
        if (value instanceof Date) {
          return value;
        }
        if (typeof value === "string" || typeof value === "number" && !isNaN(value) && isFinite(value)) {
          if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
            value = parseFloat(value);
          }
          let date;
          if (format && internals.isIsoDate(format)) {
            date = format.test(value) ? new Date(value) : internals.invalidDate;
          } else if (timestamp && multiplier) {
            date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
          } else {
            date = new Date(value);
          }
          if (!isNaN(date.getTime())) {
            return date;
          }
        }
        return null;
      }
      iso() {
        if (this._flags.format === internals.isoDate) {
          return this;
        }
        const obj = this.clone();
        obj._flags.format = internals.isoDate;
        return obj;
      }
      timestamp(type = "javascript") {
        const allowed = ["javascript", "unix"];
        Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');
        if (this._flags.timestamp === type) {
          return this;
        }
        const obj = this.clone();
        obj._flags.timestamp = type;
        obj._flags.multiplier = type === "unix" ? 1e3 : 1;
        return obj;
      }
      _isIsoDate(value) {
        return internals.isoDate.test(value);
      }
    };
    internals.compare = function(type, compare) {
      return function(date) {
        const isNow = date === "now";
        const isRef = Ref.isRef(date);
        if (!isNow && !isRef) {
          date = internals.Date.toDate(date);
        }
        Hoek.assert(date, "Invalid date format");
        return this._test(type, date, function(value, state, options) {
          let compareTo;
          if (isNow) {
            compareTo = Date.now();
          } else if (isRef) {
            compareTo = internals.Date.toDate(date(state.reference || state.parent, options));
            if (!compareTo) {
              return this.createError("date.ref", { ref: date.key }, state, options);
            }
            compareTo = compareTo.getTime();
          } else {
            compareTo = date.getTime();
          }
          if (compare(value.getTime(), compareTo)) {
            return value;
          }
          return this.createError("date." + type, { limit: new Date(compareTo) }, state, options);
        });
      };
    };
    internals.Date.prototype.min = internals.compare("min", (value, date) => value >= date);
    internals.Date.prototype.max = internals.compare("max", (value, date) => value <= date);
    module.exports = new internals.Date();
  }
});

// ../../../node_modules/topo/node_modules/hoek/lib/deep-equal.js
var require_deep_equal = __commonJS({
  "../../../node_modules/topo/node_modules/hoek/lib/deep-equal.js"(exports, module) {
    "use strict";
    var internals = {
      arrayType: Symbol("array"),
      bufferType: Symbol("buffer"),
      dateType: Symbol("date"),
      errorType: Symbol("error"),
      genericType: Symbol("generic"),
      mapType: Symbol("map"),
      regexType: Symbol("regex"),
      setType: Symbol("set"),
      weakMapType: Symbol("weak-map"),
      weakSetType: Symbol("weak-set"),
      mismatched: Symbol("mismatched")
    };
    internals.typeMap = {
      "[object Array]": internals.arrayType,
      "[object Date]": internals.dateType,
      "[object Error]": internals.errorType,
      "[object Map]": internals.mapType,
      "[object RegExp]": internals.regexType,
      "[object Set]": internals.setType,
      "[object WeakMap]": internals.weakMapType,
      "[object WeakSet]": internals.weakSetType
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
    internals.getInternalType = function(obj) {
      const { typeMap, bufferType, genericType } = internals;
      if (obj instanceof Buffer) {
        return bufferType;
      }
      const objName = Object.prototype.toString.call(obj);
      return typeMap[objName] || genericType;
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return internals.getInternalType(obj);
      }
      const type = internals.getInternalType(obj);
      if (type !== internals.getInternalType(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of obj) {
        if (!ref.has(entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === internals.arrayType) {
        if (options.part) {
          for (let i = 0; i < obj.length; ++i) {
            const objValue = obj[i];
            for (let j = 0; j < ref.length; ++j) {
              if (isDeepEqual(objValue, ref[j], options, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i = 0; i < obj.length; ++i) {
            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === internals.setType) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(ref);
          for (const objEntry of obj) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === internals.mapType) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of obj) {
          if (value === void 0 && !ref.has(key)) {
            return false;
          }
          if (!isDeepEqual(value, ref.get(key), options, seen)) {
            return false;
          }
        }
      } else if (instanceType === internals.errorType) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if (!(obj === valueOfObj && ref === valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options.part && objKeys.length !== keys(ref).length) {
        return false;
      }
      for (let i = 0; i < objKeys.length; ++i) {
        const key = objKeys[i];
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      if (options.symbols) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (let i = 0; i < objSymbols.length; ++i) {
          const key = objSymbols[i];
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.isDeepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (type !== "object" || obj === null || ref === null) {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
      switch (instanceType) {
        case internals.bufferType:
          return Buffer.prototype.equals.call(obj, ref);
        case internals.regexType:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
      } finally {
        seen.pop();
      }
    };
    module.exports = function(obj, ref, options) {
      options = options || { prototype: true };
      return !!internals.isDeepEqual(obj, ref, options, []);
    };
  }
});

// ../../../node_modules/topo/node_modules/hoek/lib/escape.js
var require_escape2 = __commonJS({
  "../../../node_modules/topo/node_modules/hoek/lib/escape.js"(exports) {
    "use strict";
    var internals = {};
    exports.escapeHtml = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    exports.escapeJson = function(input) {
      if (!input) {
        return "";
      }
      const lessThan = 60;
      const greaterThan = 62;
      const andSymbol = 38;
      const lineSeperator = 8232;
      let charCode;
      return input.replace(/[<>&\u2028\u2029]/g, (match) => {
        charCode = match.charCodeAt(0);
        if (charCode === lessThan) {
          return "\\u003c";
        }
        if (charCode === greaterThan) {
          return "\\u003e";
        }
        if (charCode === andSymbol) {
          return "\\u0026";
        }
        if (charCode === lineSeperator) {
          return "\\u2028";
        }
        return "\\u2029";
      });
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml[charCode];
      if (typeof namedEscape !== "undefined") {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = Buffer.from(String.fromCharCode(charCode), "ascii").toString("hex");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return typeof internals.safeCharCodes[charCode] !== "undefined";
    };
    internals.namedHtml = {
      "38": "&amp;",
      "60": "&lt;",
      "62": "&gt;",
      "34": "&quot;",
      "160": "&nbsp;",
      "162": "&cent;",
      "163": "&pound;",
      "164": "&curren;",
      "169": "&copy;",
      "174": "&reg;"
    };
    internals.safeCharCodes = function() {
      const safe = {};
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || // a-z
        i >= 65 && i <= 90 || // A-Z
        i >= 48 && i <= 57 || // 0-9
        i === 32 || // space
        i === 46 || // .
        i === 44 || // ,
        i === 45 || // -
        i === 58 || // :
        i === 95) {
          safe[i] = null;
        }
      }
      return safe;
    }();
  }
});

// ../../../node_modules/topo/node_modules/hoek/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/topo/node_modules/hoek/lib/index.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Crypto = require_crypto();
    var Path = require_path();
    var DeepEqual = require_deep_equal();
    var Escape = require_escape2();
    var internals = {};
    exports.deepEqual = DeepEqual;
    exports.clone = function(obj, options = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      const seen = _seen || /* @__PURE__ */ new Map();
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
      let newObj;
      let cloneDeep = false;
      const isArray = Array.isArray(obj);
      if (!isArray) {
        if (Buffer.isBuffer(obj)) {
          newObj = Buffer.from(obj);
        } else if (obj instanceof Date) {
          newObj = new Date(obj.getTime());
        } else if (obj instanceof RegExp) {
          newObj = new RegExp(obj);
        } else {
          if (options.prototype !== false) {
            const proto = Object.getPrototypeOf(obj);
            if (proto && proto.isImmutable) {
              newObj = obj;
            } else {
              newObj = Object.create(proto);
              cloneDeep = true;
            }
          } else {
            newObj = {};
            cloneDeep = true;
          }
        }
      } else {
        newObj = [];
        cloneDeep = true;
      }
      seen.set(obj, newObj);
      if (cloneDeep) {
        const keys = internals.keys(obj, options);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (isArray && key === "length") {
            continue;
          }
          const descriptor = Object.getOwnPropertyDescriptor(obj, key);
          if (descriptor && (descriptor.get || descriptor.set)) {
            Object.defineProperty(newObj, key, descriptor);
          } else {
            Object.defineProperty(newObj, key, {
              enumerable: descriptor ? descriptor.enumerable : true,
              writable: true,
              configurable: true,
              value: exports.clone(obj[key], options, seen)
            });
          }
        }
        if (isArray) {
          newObj.length = obj.length;
        }
      }
      return newObj;
    };
    internals.keys = function(obj, options = {}) {
      return options.symbols ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
    exports.merge = function(target, source, isNullOverride, isMergeArrays) {
      exports.assert(target && typeof target === "object", "Invalid target value: must be an object");
      exports.assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      if (Array.isArray(source)) {
        exports.assert(Array.isArray(target), "Cannot merge array onto an object");
        if (isMergeArrays === false) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(exports.clone(source[i]));
        }
        return target;
      }
      const keys = internals.keys(source);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {
            target[key] = exports.clone(value);
          } else {
            exports.merge(target[key], value, isNullOverride, isMergeArrays);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (isNullOverride !== false) {
            target[key] = value;
          }
        }
      }
      return target;
    };
    exports.applyToDefaults = function(defaults, options, isNullOverride) {
      exports.assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      exports.assert(!options || options === true || typeof options === "object", "Invalid options value: must be true, falsy or an object");
      if (!options) {
        return null;
      }
      const copy = exports.clone(defaults);
      if (options === true) {
        return copy;
      }
      return exports.merge(copy, options, isNullOverride === true, false);
    };
    exports.cloneWithShallow = function(source, keys, options) {
      if (!source || typeof source !== "object") {
        return source;
      }
      const storage = internals.store(source, keys);
      const copy = exports.clone(source, options);
      internals.restore(copy, source, storage);
      return copy;
    };
    internals.store = function(source, keys) {
      const storage = /* @__PURE__ */ new Map();
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = exports.reach(source, key);
        if (typeof value === "object" || typeof value === "function") {
          storage.set(key, value);
          internals.reachSet(source, key, void 0);
        }
      }
      return storage;
    };
    internals.restore = function(copy, source, storage) {
      for (const [key, value] of storage) {
        internals.reachSet(copy, key, value);
        internals.reachSet(source, key, value);
      }
    };
    internals.reachSet = function(obj, key, value) {
      const path = Array.isArray(key) ? key : key.split(".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
          ref[segment] = value;
        }
        ref = ref[segment];
      }
    };
    exports.applyToDefaultsWithShallow = function(defaults, options, keys) {
      exports.assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      exports.assert(!options || options === true || typeof options === "object", "Invalid options value: must be true, falsy or an object");
      exports.assert(keys && Array.isArray(keys), "Invalid keys");
      if (!options) {
        return null;
      }
      const copy = exports.cloneWithShallow(defaults, keys);
      if (options === true) {
        return copy;
      }
      const storage = internals.store(options, keys);
      exports.merge(copy, options, false, false);
      internals.restore(copy, options, storage);
      return copy;
    };
    exports.intersect = function(array1, array2, justFirst) {
      if (!array1 || !array2) {
        return justFirst ? null : [];
      }
      const common = [];
      const hash = Array.isArray(array1) ? new Set(array1) : array1;
      const found = /* @__PURE__ */ new Set();
      for (const value of array2) {
        if (internals.has(hash, value) && !found.has(value)) {
          if (justFirst) {
            return value;
          }
          common.push(value);
          found.add(value);
        }
      }
      return justFirst ? null : common;
    };
    internals.has = function(ref, key) {
      if (typeof ref.has === "function") {
        return ref.has(key);
      }
      return ref[key] !== void 0;
    };
    exports.contain = function(ref, values, options = {}) {
      let valuePairs = null;
      if (typeof ref === "object" && typeof values === "object" && !Array.isArray(ref) && !Array.isArray(values)) {
        valuePairs = values;
        const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));
        values = [...Object.keys(values), ...symbols];
      } else {
        values = [].concat(values);
      }
      exports.assert(typeof ref === "string" || typeof ref === "object", "Reference must be string or an object");
      exports.assert(values.length, "Values array cannot be empty");
      let compare;
      let compareFlags;
      if (options.deep) {
        compare = exports.deepEqual;
        const hasOnly = options.hasOwnProperty("only");
        const hasPart = options.hasOwnProperty("part");
        compareFlags = {
          prototype: hasOnly ? options.only : hasPart ? !options.part : false,
          part: hasOnly ? !options.only : hasPart ? options.part : false
        };
      } else {
        compare = (a, b) => a === b;
      }
      let misses = false;
      const matches = new Array(values.length);
      for (let i = 0; i < matches.length; ++i) {
        matches[i] = 0;
      }
      if (typeof ref === "string") {
        let pattern = "(";
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          exports.assert(typeof value === "string", "Cannot compare string reference to non-string value");
          pattern += (i ? "|" : "") + exports.escapeRegex(value);
        }
        const regex = new RegExp(pattern + ")", "g");
        const leftovers = ref.replace(regex, ($0, $1) => {
          const index = values.indexOf($1);
          ++matches[index];
          return "";
        });
        misses = !!leftovers;
      } else if (Array.isArray(ref)) {
        const onlyOnce = !!(options.only && options.once);
        if (onlyOnce && ref.length !== values.length) {
          return false;
        }
        for (let i = 0; i < ref.length; ++i) {
          let matched = false;
          for (let j = 0; j < values.length && matched === false; ++j) {
            if (!onlyOnce || matches[j] === 0) {
              matched = compare(values[j], ref[i], compareFlags) && j;
            }
          }
          if (matched !== false) {
            ++matches[matched];
          } else {
            misses = true;
          }
        }
      } else {
        const keys = internals.keys(ref, options);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          const pos = values.indexOf(key);
          if (pos !== -1) {
            if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {
              return false;
            }
            ++matches[pos];
          } else {
            misses = true;
          }
        }
      }
      if (options.only) {
        if (misses || !options.once) {
          return !misses;
        }
      }
      let result = false;
      for (let i = 0; i < matches.length; ++i) {
        result = result || !!matches[i];
        if (options.once && matches[i] > 1 || !options.part && !matches[i]) {
          return false;
        }
      }
      return result;
    };
    exports.flatten = function(array, target) {
      const result = target || [];
      for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
          exports.flatten(array[i], result);
        } else {
          result.push(array[i]);
        }
      }
      return result;
    };
    exports.reach = function(obj, chain, options) {
      if (chain === false || chain === null || typeof chain === "undefined") {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const isChainArray = Array.isArray(chain);
      exports.assert(!isChainArray || !options.separator, "Separator option no valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        if (Array.isArray(ref)) {
          const number = Number(key);
          if (Number.isInteger(number) && number < 0) {
            key = ref.length + number;
          }
        }
        if (!ref || !((typeof ref === "object" || typeof ref === "function") && key in ref) || typeof ref !== "object" && options.functions === false) {
          exports.assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          exports.assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        ref = ref[key];
      }
      return ref;
    };
    exports.reachTemplate = function(obj, template, options) {
      return template.replace(/{([^}]+)}/g, ($0, chain) => {
        const value = exports.reach(obj, chain, options);
        return value === void 0 || value === null ? "" : value;
      });
    };
    exports.assert = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);
      });
      throw new Assert.AssertionError({
        message: msgs.join(" ") || "Unknown error",
        actual: false,
        expected: true,
        operator: "==",
        stackStartFunction: exports.assert
      });
    };
    exports.Bench = function() {
      this.ts = 0;
      this.reset();
    };
    exports.Bench.prototype.reset = function() {
      this.ts = exports.Bench.now();
    };
    exports.Bench.prototype.elapsed = function() {
      return exports.Bench.now() - this.ts;
    };
    exports.Bench.now = function() {
      const ts = process.hrtime();
      return ts[0] * 1e3 + ts[1] / 1e6;
    };
    exports.escapeRegex = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
    exports.escapeHeaderAttribute = function(attribute) {
      exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
    exports.escapeHtml = function(string) {
      return Escape.escapeHtml(string);
    };
    exports.escapeJson = function(string) {
      return Escape.escapeJson(string);
    };
    exports.once = function(method) {
      if (method._hoekOnce) {
        return method;
      }
      let once = false;
      const wrapped = function(...args) {
        if (!once) {
          once = true;
          method(...args);
        }
      };
      wrapped._hoekOnce = true;
      return wrapped;
    };
    exports.ignore = function() {
    };
    exports.uniqueFilename = function(path, extension) {
      if (extension) {
        extension = extension[0] !== "." ? "." + extension : extension;
      } else {
        extension = "";
      }
      path = Path.resolve(path);
      const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
      return Path.join(path, name);
    };
    exports.stringify = function(...args) {
      try {
        return JSON.stringify.apply(null, args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
    exports.wait = function(timeout) {
      return new Promise((resolve) => setTimeout(resolve, timeout));
    };
    exports.block = function() {
      return new Promise(exports.ignore);
    };
  }
});

// ../../../node_modules/topo/lib/index.js
var require_lib3 = __commonJS({
  "../../../node_modules/topo/lib/index.js"(exports, module) {
    "use strict";
    var Hoek = require_lib2();
    var internals = {};
    module.exports = class Topo {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options) {
        options = options || {};
        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || "?";
        const sort = options.sort || 0;
        Hoek.assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Hoek.assert(!before.includes("?"), "Item cannot come before unassociated items");
        Hoek.assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Hoek.assert(!after.includes("?"), "Item cannot come after unassociated items");
        [].concat(nodes).forEach((node, i) => {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        });
        const error2 = this._sort();
        Hoek.assert(!error2, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        return this.nodes;
      }
      merge(others) {
        others = [].concat(others);
        for (let i = 0; i < others.length; ++i) {
          const other = others[i];
          if (other) {
            for (let j = 0; j < other._items.length; ++j) {
              const item = Object.assign({}, other._items[j]);
              this._items.push(item);
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
          this._items[i].seq = i;
        }
        const error2 = this._sort();
        Hoek.assert(!error2, "merge created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < this._items.length; ++i) {
          const item = this._items[i];
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] || [];
          groups[group].push(seq);
          graph[seq] = item.before;
          const after = item.after;
          for (let j = 0; j < after.length; ++j) {
            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
          }
        }
        let graphNodes = Object.keys(graph);
        for (let i = 0; i < graphNodes.length; ++i) {
          const node = graphNodes[i];
          const expandedGroups = [];
          const graphNodeItems = Object.keys(graph[node]);
          for (let j = 0; j < graphNodeItems.length; ++j) {
            const group = graph[node][graphNodeItems[j]];
            groups[group] = groups[group] || [];
            for (let k = 0; k < groups[group].length; ++k) {
              expandedGroups.push(groups[group][k]);
            }
          }
          graph[node] = expandedGroups;
        }
        const afterNodes = Object.keys(graphAfters);
        for (let i = 0; i < afterNodes.length; ++i) {
          const group = afterNodes[i];
          if (groups[group]) {
            for (let j = 0; j < groups[group].length; ++j) {
              const node = groups[group][j];
              graph[node] = graph[node].concat(graphAfters[group]);
            }
          }
        }
        let children;
        const ancestors = {};
        graphNodes = Object.keys(graph);
        for (let i = 0; i < graphNodes.length; ++i) {
          const node = graphNodes[i];
          children = graph[node];
          for (let j = 0; j < children.length; ++j) {
            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i = 0; i < this._items.length; ++i) {
          let next = i;
          if (ancestors[i]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return new Error("Invalid dependencies");
        }
        const seqIndex = {};
        for (let i = 0; i < this._items.length; ++i) {
          const item = this._items[i];
          seqIndex[item.seq] = item;
        }
        const sortedNodes = [];
        this._items = sorted.map((value) => {
          const sortedItem = seqIndex[value];
          sortedNodes.push(sortedItem.node);
          return sortedItem;
        });
        this.nodes = sortedNodes;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// ../../../node_modules/joi/lib/types/object/index.js
var require_object = __commonJS({
  "../../../node_modules/joi/lib/types/object/index.js"(exports, module) {
    "use strict";
    var Hoek = require_lib();
    var Topo = require_lib3();
    var Any = require_any();
    var Errors = require_errors();
    var Cast = require_cast();
    var internals = {};
    internals.Object = class extends Any {
      constructor() {
        super();
        this._type = "object";
        this._inner.children = null;
        this._inner.renames = [];
        this._inner.dependencies = [];
        this._inner.patterns = [];
      }
      _base(value, state, options) {
        let target = value;
        const errors2 = [];
        const finish = () => {
          return {
            value: target,
            errors: errors2.length ? errors2 : null
          };
        };
        if (typeof value === "string" && options.convert) {
          value = internals.safeParse(value);
        }
        const type = this._flags.func ? "function" : "object";
        if (!value || typeof value !== type || Array.isArray(value)) {
          errors2.push(this.createError(type + ".base", null, state, options));
          return finish();
        }
        if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys
        !this._inner.patterns.length) {
          target = value;
          return finish();
        }
        if (target === value) {
          if (type === "object") {
            target = Object.create(Object.getPrototypeOf(value));
          } else {
            target = function(...args) {
              return value.apply(this, args);
            };
            target.prototype = Hoek.clone(value.prototype);
          }
          const valueKeys = Object.keys(value);
          for (let i = 0; i < valueKeys.length; ++i) {
            target[valueKeys[i]] = value[valueKeys[i]];
          }
        } else {
          target = value;
        }
        const renamed = {};
        for (let i = 0; i < this._inner.renames.length; ++i) {
          const rename = this._inner.renames[i];
          if (rename.isRegExp) {
            const targetKeys = Object.keys(target);
            const matchedTargetKeys = [];
            for (let j = 0; j < targetKeys.length; ++j) {
              if (rename.from.test(targetKeys[j])) {
                matchedTargetKeys.push(targetKeys[j]);
              }
            }
            const allUndefined = matchedTargetKeys.every((key) => target[key] === void 0);
            if (rename.options.ignoreUndefined && allUndefined) {
              continue;
            }
            if (!rename.options.multiple && renamed[rename.to]) {
              errors2.push(this.createError("object.rename.regex.multiple", { from: matchedTargetKeys, to: rename.to }, state, options));
              if (options.abortEarly) {
                return finish();
              }
            }
            if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
              errors2.push(this.createError("object.rename.regex.override", { from: matchedTargetKeys, to: rename.to }, state, options));
              if (options.abortEarly) {
                return finish();
              }
            }
            if (allUndefined) {
              delete target[rename.to];
            } else {
              target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
            }
            renamed[rename.to] = true;
            if (!rename.options.alias) {
              for (let j = 0; j < matchedTargetKeys.length; ++j) {
                delete target[matchedTargetKeys[j]];
              }
            }
          } else {
            if (rename.options.ignoreUndefined && target[rename.from] === void 0) {
              continue;
            }
            if (!rename.options.multiple && renamed[rename.to]) {
              errors2.push(this.createError("object.rename.multiple", { from: rename.from, to: rename.to }, state, options));
              if (options.abortEarly) {
                return finish();
              }
            }
            if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
              errors2.push(this.createError("object.rename.override", { from: rename.from, to: rename.to }, state, options));
              if (options.abortEarly) {
                return finish();
              }
            }
            if (target[rename.from] === void 0) {
              delete target[rename.to];
            } else {
              target[rename.to] = target[rename.from];
            }
            renamed[rename.to] = true;
            if (!rename.options.alias) {
              delete target[rename.from];
            }
          }
        }
        if (!this._inner.children && // null allows any keys
        !this._inner.patterns.length && !this._inner.dependencies.length) {
          return finish();
        }
        const unprocessed = Hoek.mapToObject(Object.keys(target));
        if (this._inner.children) {
          const stripProps = [];
          for (let i = 0; i < this._inner.children.length; ++i) {
            const child = this._inner.children[i];
            const key = child.key;
            const item = target[key];
            delete unprocessed[key];
            const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };
            const result = child.schema._validate(item, localState, options);
            if (result.errors) {
              errors2.push(this.createError("object.child", { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));
              if (options.abortEarly) {
                return finish();
              }
            } else {
              if (child.schema._flags.strip || result.value === void 0 && result.value !== item) {
                stripProps.push(key);
                target[key] = result.finalValue;
              } else if (result.value !== void 0) {
                target[key] = result.value;
              }
            }
          }
          for (let i = 0; i < stripProps.length; ++i) {
            delete target[stripProps[i]];
          }
        }
        let unprocessedKeys = Object.keys(unprocessed);
        if (unprocessedKeys.length && this._inner.patterns.length) {
          for (let i = 0; i < unprocessedKeys.length; ++i) {
            const key = unprocessedKeys[i];
            const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };
            const item = target[key];
            for (let j = 0; j < this._inner.patterns.length; ++j) {
              const pattern = this._inner.patterns[j];
              if (pattern.regex.test(key)) {
                delete unprocessed[key];
                const result = pattern.rule._validate(item, localState, options);
                if (result.errors) {
                  errors2.push(this.createError("object.child", { key, child: pattern.rule._getLabel(key), reason: result.errors }, localState, options));
                  if (options.abortEarly) {
                    return finish();
                  }
                }
                target[key] = result.value;
              }
            }
          }
          unprocessedKeys = Object.keys(unprocessed);
        }
        if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {
          if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {
            const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;
            for (let i = 0; i < unprocessedKeys.length; ++i) {
              const key = unprocessedKeys[i];
              if (stripUnknown) {
                delete target[key];
                delete unprocessed[key];
              } else if (typeof target[key] === "function") {
                delete unprocessed[key];
              }
            }
            unprocessedKeys = Object.keys(unprocessed);
          }
          if (unprocessedKeys.length && (this._flags.allowUnknown !== void 0 ? !this._flags.allowUnknown : !options.allowUnknown)) {
            for (let i = 0; i < unprocessedKeys.length; ++i) {
              const unprocessedKey = unprocessedKeys[i];
              errors2.push(this.createError("object.allowUnknown", { child: unprocessedKey }, { key: unprocessedKey, path: state.path.concat(unprocessedKey) }, options, {}));
            }
          }
        }
        for (let i = 0; i < this._inner.dependencies.length; ++i) {
          const dep = this._inner.dependencies[i];
          const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);
          if (err instanceof Errors.Err) {
            errors2.push(err);
            if (options.abortEarly) {
              return finish();
            }
          }
        }
        return finish();
      }
      keys(schema) {
        Hoek.assert(schema === null || schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
        Hoek.assert(!schema || !(schema instanceof Any), "Object schema cannot be a joi schema");
        const obj = this.clone();
        if (!schema) {
          obj._inner.children = null;
          return obj;
        }
        const children = Object.keys(schema);
        if (!children.length) {
          obj._inner.children = [];
          return obj;
        }
        const topo = new Topo();
        if (obj._inner.children) {
          for (let i = 0; i < obj._inner.children.length; ++i) {
            const child = obj._inner.children[i];
            if (!children.includes(child.key)) {
              topo.add(child, { after: child._refs, group: child.key });
            }
          }
        }
        for (let i = 0; i < children.length; ++i) {
          const key = children[i];
          const child = schema[key];
          try {
            const cast = Cast.schema(this._currentJoi, child);
            topo.add({ key, schema: cast }, { after: cast._refs, group: key });
          } catch (castErr) {
            if (castErr.hasOwnProperty("path")) {
              castErr.path = key + "." + castErr.path;
            } else {
              castErr.path = key;
            }
            throw castErr;
          }
        }
        obj._inner.children = topo.nodes;
        return obj;
      }
      unknown(allow) {
        const value = allow !== false;
        if (this._flags.allowUnknown === value) {
          return this;
        }
        const obj = this.clone();
        obj._flags.allowUnknown = value;
        return obj;
      }
      length(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("length", limit, function(value, state, options) {
          if (Object.keys(value).length === limit) {
            return value;
          }
          return this.createError("object.length", { limit }, state, options);
        });
      }
      min(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("min", limit, function(value, state, options) {
          if (Object.keys(value).length >= limit) {
            return value;
          }
          return this.createError("object.min", { limit }, state, options);
        });
      }
      max(limit) {
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
        return this._test("max", limit, function(value, state, options) {
          if (Object.keys(value).length <= limit) {
            return value;
          }
          return this.createError("object.max", { limit }, state, options);
        });
      }
      pattern(pattern, schema) {
        Hoek.assert(pattern instanceof RegExp, "Invalid regular expression");
        Hoek.assert(schema !== void 0, "Invalid rule");
        pattern = new RegExp(pattern.source, pattern.ignoreCase ? "i" : void 0);
        try {
          schema = Cast.schema(this._currentJoi, schema);
        } catch (castErr) {
          if (castErr.hasOwnProperty("path")) {
            castErr.message = castErr.message + "(" + castErr.path + ")";
          }
          throw castErr;
        }
        const obj = this.clone();
        obj._inner.patterns.push({ regex: pattern, rule: schema });
        return obj;
      }
      schema() {
        return this._test("schema", null, function(value, state, options) {
          if (value instanceof Any) {
            return value;
          }
          return this.createError("object.schema", null, state, options);
        });
      }
      with(key, peers) {
        return this._dependency("with", key, peers);
      }
      without(key, peers) {
        return this._dependency("without", key, peers);
      }
      xor(...peers) {
        peers = Hoek.flatten(peers);
        return this._dependency("xor", null, peers);
      }
      or(...peers) {
        peers = Hoek.flatten(peers);
        return this._dependency("or", null, peers);
      }
      and(...peers) {
        peers = Hoek.flatten(peers);
        return this._dependency("and", null, peers);
      }
      nand(...peers) {
        peers = Hoek.flatten(peers);
        return this._dependency("nand", null, peers);
      }
      requiredKeys(...children) {
        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, "required");
      }
      optionalKeys(...children) {
        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, "optional");
      }
      forbiddenKeys(...children) {
        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, "forbidden");
      }
      rename(from, to, options) {
        Hoek.assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
        Hoek.assert(typeof to === "string", "Rename missing the to argument");
        Hoek.assert(to !== from, "Cannot rename key to same name:", from);
        for (let i = 0; i < this._inner.renames.length; ++i) {
          Hoek.assert(this._inner.renames[i].from !== from, "Cannot rename the same key multiple times");
        }
        const obj = this.clone();
        obj._inner.renames.push({
          from,
          to,
          options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
          isRegExp: from instanceof RegExp
        });
        return obj;
      }
      applyFunctionToChildren(children, fn, args, root) {
        children = [].concat(children);
        Hoek.assert(children.length > 0, "expected at least one children");
        const groupedChildren = internals.groupChildren(children);
        let obj;
        if ("" in groupedChildren) {
          obj = this[fn].apply(this, args);
          delete groupedChildren[""];
        } else {
          obj = this.clone();
        }
        if (obj._inner.children) {
          root = root ? root + "." : "";
          for (let i = 0; i < obj._inner.children.length; ++i) {
            const child = obj._inner.children[i];
            const group = groupedChildren[child.key];
            if (group) {
              obj._inner.children[i] = {
                key: child.key,
                _refs: child._refs,
                schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
              };
              delete groupedChildren[child.key];
            }
          }
        }
        const remaining = Object.keys(groupedChildren);
        Hoek.assert(remaining.length === 0, "unknown key(s)", remaining.join(", "));
        return obj;
      }
      _dependency(type, key, peers) {
        peers = [].concat(peers);
        for (let i = 0; i < peers.length; ++i) {
          Hoek.assert(typeof peers[i] === "string", type, "peers must be a string or array of strings");
        }
        const obj = this.clone();
        obj._inner.dependencies.push({ type, key, peers });
        return obj;
      }
      describe(shallow) {
        const description = Any.prototype.describe.call(this);
        if (description.rules) {
          for (let i = 0; i < description.rules.length; ++i) {
            const rule = description.rules[i];
            if (
              /* $lab:coverage:off$ */
              rule.arg && typeof rule.arg === "object" && rule.arg.schema && rule.arg.ref
            ) {
              rule.arg = {
                schema: rule.arg.schema.describe(),
                ref: rule.arg.ref.toString()
              };
            }
          }
        }
        if (this._inner.children && !shallow) {
          description.children = {};
          for (let i = 0; i < this._inner.children.length; ++i) {
            const child = this._inner.children[i];
            description.children[child.key] = child.schema.describe();
          }
        }
        if (this._inner.dependencies.length) {
          description.dependencies = Hoek.clone(this._inner.dependencies);
        }
        if (this._inner.patterns.length) {
          description.patterns = [];
          for (let i = 0; i < this._inner.patterns.length; ++i) {
            const pattern = this._inner.patterns[i];
            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
          }
        }
        if (this._inner.renames.length > 0) {
          description.renames = Hoek.clone(this._inner.renames);
        }
        return description;
      }
      assert(ref, schema, message) {
        ref = Cast.ref(ref);
        Hoek.assert(ref.isContext || ref.depth > 1, "Cannot use assertions for root level references - use direct key rules instead");
        message = message || "pass the assertion test";
        try {
          schema = Cast.schema(this._currentJoi, schema);
        } catch (castErr) {
          if (castErr.hasOwnProperty("path")) {
            castErr.message = castErr.message + "(" + castErr.path + ")";
          }
          throw castErr;
        }
        const key = ref.path[ref.path.length - 1];
        const path = ref.path.join(".");
        return this._test("assert", { schema, ref }, function(value, state, options) {
          const result = schema._validate(ref(value), null, options, value);
          if (!result.errors) {
            return value;
          }
          const localState = Hoek.merge({}, state);
          localState.key = key;
          localState.path = ref.path;
          return this.createError("object.assert", { ref: path, message }, localState, options);
        });
      }
      type(constructor, name = constructor.name) {
        Hoek.assert(typeof constructor === "function", "type must be a constructor function");
        const typeData = {
          name,
          ctor: constructor
        };
        return this._test("type", typeData, function(value, state, options) {
          if (value instanceof constructor) {
            return value;
          }
          return this.createError("object.type", { type: typeData.name }, state, options);
        });
      }
    };
    internals.safeParse = function(value) {
      try {
        return JSON.parse(value);
      } catch (parseErr) {
      }
      return value;
    };
    internals.renameDefaults = {
      alias: false,
      // Keep old value in place
      multiple: false,
      // Allow renaming multiple keys into the same target
      override: false
      // Overrides an existing key
    };
    internals.groupChildren = function(children) {
      children.sort();
      const grouped = {};
      for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        Hoek.assert(typeof child === "string", "children must be strings");
        const group = child.split(".")[0];
        const childGroup = grouped[group] = grouped[group] || [];
        childGroup.push(child.substring(group.length + 1));
      }
      return grouped;
    };
    internals.keysToLabels = function(schema, keys) {
      const children = schema._inner.children;
      if (!children) {
        return keys;
      }
      const findLabel = function(key) {
        const matchingChild = children.find((child) => child.key === key);
        return matchingChild ? matchingChild.schema._getLabel(key) : key;
      };
      if (Array.isArray(keys)) {
        return keys.map(findLabel);
      }
      return findLabel(keys);
    };
    internals.with = function(value, peers, parent, state, options) {
      if (value === void 0) {
        return value;
      }
      for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === void 0) {
          return this.createError("object.with", {
            main: state.key,
            mainWithLabel: internals.keysToLabels(this, state.key),
            peer,
            peerWithLabel: internals.keysToLabels(this, peer)
          }, state, options);
        }
      }
      return value;
    };
    internals.without = function(value, peers, parent, state, options) {
      if (value === void 0) {
        return value;
      }
      for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
          return this.createError("object.without", {
            main: state.key,
            mainWithLabel: internals.keysToLabels(this, state.key),
            peer,
            peerWithLabel: internals.keysToLabels(this, peer)
          }, state, options);
        }
      }
      return value;
    };
    internals.xor = function(value, peers, parent, state, options) {
      const present = [];
      for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
          present.push(peer);
        }
      }
      if (present.length === 1) {
        return value;
      }
      const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };
      if (present.length === 0) {
        return this.createError("object.missing", context, state, options);
      }
      return this.createError("object.xor", context, state, options);
    };
    internals.or = function(value, peers, parent, state, options) {
      for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
          return value;
        }
      }
      return this.createError("object.missing", {
        peers,
        peersWithLabels: internals.keysToLabels(this, peers)
      }, state, options);
    };
    internals.and = function(value, peers, parent, state, options) {
      const missing = [];
      const present = [];
      const count = peers.length;
      for (let i = 0; i < count; ++i) {
        const peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === void 0) {
          missing.push(peer);
        } else {
          present.push(peer);
        }
      }
      const aon = missing.length === count || present.length === count;
      if (!aon) {
        return this.createError("object.and", {
          present,
          presentWithLabels: internals.keysToLabels(this, present),
          missing,
          missingWithLabels: internals.keysToLabels(this, missing)
        }, state, options);
      }
    };
    internals.nand = function(value, peers, parent, state, options) {
      const present = [];
      for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
          present.push(peer);
        }
      }
      const values = Hoek.clone(peers);
      const main = values.splice(0, 1)[0];
      const allPresent = present.length === peers.length;
      return allPresent ? this.createError("object.nand", {
        main,
        mainWithLabel: internals.keysToLabels(this, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(this, values)
      }, state, options) : null;
    };
    module.exports = new internals.Object();
  }
});

// ../../../node_modules/joi/lib/types/func/index.js
var require_func = __commonJS({
  "../../../node_modules/joi/lib/types/func/index.js"(exports, module) {
    "use strict";
    var Hoek = require_lib();
    var ObjectType = require_object();
    var Ref = require_ref();
    var internals = {};
    internals.Func = class extends ObjectType.constructor {
      constructor() {
        super();
        this._flags.func = true;
      }
      arity(n) {
        Hoek.assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
        return this._test("arity", n, function(value, state, options) {
          if (value.length === n) {
            return value;
          }
          return this.createError("function.arity", { n }, state, options);
        });
      }
      minArity(n) {
        Hoek.assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
        return this._test("minArity", n, function(value, state, options) {
          if (value.length >= n) {
            return value;
          }
          return this.createError("function.minArity", { n }, state, options);
        });
      }
      maxArity(n) {
        Hoek.assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
        return this._test("maxArity", n, function(value, state, options) {
          if (value.length <= n) {
            return value;
          }
          return this.createError("function.maxArity", { n }, state, options);
        });
      }
      ref() {
        return this._test("ref", null, function(value, state, options) {
          if (Ref.isRef(value)) {
            return value;
          }
          return this.createError("function.ref", null, state, options);
        });
      }
      class() {
        return this._test("class", null, function(value, state, options) {
          if (/^\s*class\s/.test(value.toString())) {
            return value;
          }
          return this.createError("function.class", null, state, options);
        });
      }
    };
    module.exports = new internals.Func();
  }
});

// ../../../node_modules/joi/lib/types/number/index.js
var require_number = __commonJS({
  "../../../node_modules/joi/lib/types/number/index.js"(exports, module) {
    "use strict";
    var Any = require_any();
    var Ref = require_ref();
    var Hoek = require_lib();
    var internals = {
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
    };
    internals.Number = class extends Any {
      constructor() {
        super();
        this._type = "number";
        this._invalids.add(Infinity);
        this._invalids.add(-Infinity);
      }
      _base(value, state, options) {
        const result = {
          errors: null,
          value
        };
        if (typeof value === "string" && options.convert) {
          const number = parseFloat(value);
          result.value = isNaN(number) || !isFinite(value) ? NaN : number;
        }
        const isNumber = typeof result.value === "number" && !isNaN(result.value);
        if (options.convert && "precision" in this._flags && isNumber) {
          const precision = Math.pow(10, this._flags.precision);
          result.value = Math.round(result.value * precision) / precision;
        }
        result.errors = isNumber ? null : this.createError("number.base", null, state, options);
        return result;
      }
      multiple(base2) {
        const isRef = Ref.isRef(base2);
        if (!isRef) {
          Hoek.assert(typeof base2 === "number" && isFinite(base2), "multiple must be a number");
          Hoek.assert(base2 > 0, "multiple must be greater than 0");
        }
        return this._test("multiple", base2, function(value, state, options) {
          const divisor = isRef ? base2(state.reference || state.parent, options) : base2;
          if (isRef && (typeof divisor !== "number" || !isFinite(divisor))) {
            return this.createError("number.ref", { ref: base2.key }, state, options);
          }
          if (value % divisor === 0) {
            return value;
          }
          return this.createError("number.multiple", { multiple: base2, value }, state, options);
        });
      }
      integer() {
        return this._test("integer", void 0, function(value, state, options) {
          return Number.isSafeInteger(value) ? value : this.createError("number.integer", { value }, state, options);
        });
      }
      negative() {
        return this._test("negative", void 0, function(value, state, options) {
          if (value < 0) {
            return value;
          }
          return this.createError("number.negative", { value }, state, options);
        });
      }
      positive() {
        return this._test("positive", void 0, function(value, state, options) {
          if (value > 0) {
            return value;
          }
          return this.createError("number.positive", { value }, state, options);
        });
      }
      precision(limit) {
        Hoek.assert(Number.isSafeInteger(limit), "limit must be an integer");
        Hoek.assert(!("precision" in this._flags), "precision already set");
        const obj = this._test("precision", limit, function(value, state, options) {
          const places = value.toString().match(internals.precisionRx);
          const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
          if (decimals <= limit) {
            return value;
          }
          return this.createError("number.precision", { limit, value }, state, options);
        });
        obj._flags.precision = limit;
        return obj;
      }
    };
    internals.compare = function(type, compare) {
      return function(limit) {
        const isRef = Ref.isRef(limit);
        const isNumber = typeof limit === "number" && !isNaN(limit);
        Hoek.assert(isNumber || isRef, "limit must be a number or reference");
        return this._test(type, limit, function(value, state, options) {
          let compareTo;
          if (isRef) {
            compareTo = limit(state.reference || state.parent, options);
            if (!(typeof compareTo === "number" && !isNaN(compareTo))) {
              return this.createError("number.ref", { ref: limit.key }, state, options);
            }
          } else {
            compareTo = limit;
          }
          if (compare(value, compareTo)) {
            return value;
          }
          return this.createError("number." + type, { limit: compareTo, value }, state, options);
        });
      };
    };
    internals.Number.prototype.min = internals.compare("min", (value, limit) => value >= limit);
    internals.Number.prototype.max = internals.compare("max", (value, limit) => value <= limit);
    internals.Number.prototype.greater = internals.compare("greater", (value, limit) => value > limit);
    internals.Number.prototype.less = internals.compare("less", (value, limit) => value < limit);
    module.exports = new internals.Number();
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/joi/lib/types/string/rfc3986.js
var require_rfc3986 = __commonJS({
  "../../../node_modules/joi/lib/types/string/rfc3986.js"(exports, module) {
    "use strict";
    var internals = {
      rfc3986: {}
    };
    internals.generate = function() {
      const or = "|";
      const zeroPad = "0?";
      const digit = "0-9";
      const digitOnly = "[" + digit + "]";
      const alpha = "a-zA-Z";
      const alphaOnly = "[" + alpha + "]";
      internals.rfc3986.ipv4Cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
      internals.rfc3986.ipv6Cidr = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1[01]" + digitOnly + or + "12[0-8])";
      const hexDigit = digit + "A-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = alpha + digit + "-\\._~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
      internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
      internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
      const host = "(?:" + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
      const port = digitOnly + "*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
      internals.rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ")";
      internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
    };
    internals.generate();
    module.exports = internals.rfc3986;
  }
});

// ../../../node_modules/joi/lib/types/string/uri.js
var require_uri = __commonJS({
  "../../../node_modules/joi/lib/types/string/uri.js"(exports, module) {
    "use strict";
    var RFC3986 = require_rfc3986();
    var internals = {
      Uri: {
        createUriRegex: function(optionalScheme, allowRelative, relativeOnly) {
          let scheme = RFC3986.scheme;
          let prefix;
          if (relativeOnly) {
            prefix = "(?:" + RFC3986.relativeRef + ")";
          } else {
            if (optionalScheme) {
              scheme = "(?:" + optionalScheme + ")";
            }
            const withScheme = "(?:" + scheme + ":" + RFC3986.hierPart + ")";
            prefix = allowRelative ? "(?:" + withScheme + "|" + RFC3986.relativeRef + ")" : withScheme;
          }
          return new RegExp("^" + prefix + "(?:\\?" + RFC3986.query + ")?(?:#" + RFC3986.fragment + ")?$");
        }
      }
    };
    module.exports = internals.Uri;
  }
});

// ../../../node_modules/joi/lib/types/string/ip.js
var require_ip = __commonJS({
  "../../../node_modules/joi/lib/types/string/ip.js"(exports, module) {
    "use strict";
    var RFC3986 = require_rfc3986();
    var internals = {
      Ip: {
        cidrs: {
          ipv4: {
            required: "\\/(?:" + RFC3986.ipv4Cidr + ")",
            optional: "(?:\\/(?:" + RFC3986.ipv4Cidr + "))?",
            forbidden: ""
          },
          ipv6: {
            required: "\\/" + RFC3986.ipv6Cidr,
            optional: "(?:\\/" + RFC3986.ipv6Cidr + ")?",
            forbidden: ""
          },
          ipvfuture: {
            required: "\\/" + RFC3986.ipv6Cidr,
            optional: "(?:\\/" + RFC3986.ipv6Cidr + ")?",
            forbidden: ""
          }
        },
        versions: {
          ipv4: RFC3986.IPv4address,
          ipv6: RFC3986.IPv6address,
          ipvfuture: RFC3986.IPvFuture
        }
      }
    };
    internals.Ip.createIpRegex = function(versions, cidr) {
      let regex;
      for (let i = 0; i < versions.length; ++i) {
        const version = versions[i];
        if (!regex) {
          regex = "^(?:" + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        } else {
          regex += "|" + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
      }
      return new RegExp(regex + ")$");
    };
    module.exports = internals.Ip;
  }
});

// ../../../node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "../../../node_modules/punycode/punycode.es6.js"() {
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (array) => String.fromCodePoint(...array);
    basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        let oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// ../../../node_modules/isemail/lib/index.js
var require_lib4 = __commonJS({
  "../../../node_modules/isemail/lib/index.js"(exports) {
    "use strict";
    var Punycode = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
    var Util = require_util();
    var internals = {
      hasOwn: Object.prototype.hasOwnProperty,
      indexOf: Array.prototype.indexOf,
      defaultThreshold: 16,
      maxIPv6Groups: 8,
      categories: {
        valid: 1,
        dnsWarn: 7,
        rfc5321: 15,
        cfws: 31,
        deprecated: 63,
        rfc5322: 127,
        error: 255
      },
      diagnoses: {
        // Address is valid
        valid: 0,
        // Address is valid for SMTP but has unusual elements
        rfc5321TLD: 9,
        rfc5321TLDNumeric: 10,
        rfc5321QuotedString: 11,
        rfc5321AddressLiteral: 12,
        // Address is valid for message, but must be modified for envelope
        cfwsComment: 17,
        cfwsFWS: 18,
        // Address contains non-ASCII when the allowUnicode option is false
        // Has to be > internals.defaultThreshold so that it's rejected
        // without an explicit errorLevel:
        undesiredNonAscii: 25,
        // Address contains deprecated elements, but may still be valid in some contexts
        deprecatedLocalPart: 33,
        deprecatedFWS: 34,
        deprecatedQTEXT: 35,
        deprecatedQP: 36,
        deprecatedComment: 37,
        deprecatedCTEXT: 38,
        deprecatedIPv6: 39,
        deprecatedCFWSNearAt: 49,
        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid
        rfc5322Domain: 65,
        rfc5322TooLong: 66,
        rfc5322LocalTooLong: 67,
        rfc5322DomainTooLong: 68,
        rfc5322LabelTooLong: 69,
        rfc5322DomainLiteral: 70,
        rfc5322DomainLiteralOBSDText: 71,
        rfc5322IPv6GroupCount: 72,
        rfc5322IPv62x2xColon: 73,
        rfc5322IPv6BadCharacter: 74,
        rfc5322IPv6MaxGroups: 75,
        rfc5322IPv6ColonStart: 76,
        rfc5322IPv6ColonEnd: 77,
        // Address is invalid for any purpose
        errExpectingDTEXT: 129,
        errNoLocalPart: 130,
        errNoDomain: 131,
        errConsecutiveDots: 132,
        errATEXTAfterCFWS: 133,
        errATEXTAfterQS: 134,
        errATEXTAfterDomainLiteral: 135,
        errExpectingQPair: 136,
        errExpectingATEXT: 137,
        errExpectingQTEXT: 138,
        errExpectingCTEXT: 139,
        errBackslashEnd: 140,
        errDotStart: 141,
        errDotEnd: 142,
        errDomainHyphenStart: 143,
        errDomainHyphenEnd: 144,
        errUnclosedQuotedString: 145,
        errUnclosedComment: 146,
        errUnclosedDomainLiteral: 147,
        errFWSCRLFx2: 148,
        errFWSCRLFEnd: 149,
        errCRNoLF: 150,
        errUnknownTLD: 160,
        errDomainTooShort: 161,
        errDotAfterDomainLiteral: 162
      },
      components: {
        localpart: 0,
        domain: 1,
        literal: 2,
        contextComment: 3,
        contextFWS: 4,
        contextQuotedString: 5,
        contextQuotedPair: 6
      }
    };
    internals.specials = function() {
      const specials = '()<>[]:;@\\,."';
      const lookup = new Array(256);
      lookup.fill(false);
      for (let i = 0; i < specials.length; ++i) {
        lookup[specials.codePointAt(i)] = true;
      }
      return function(code) {
        return lookup[code];
      };
    }();
    internals.c0Controls = function() {
      const lookup = new Array(256);
      lookup.fill(false);
      for (let i = 0; i < 33; ++i) {
        lookup[i] = true;
      }
      return function(code) {
        return lookup[code];
      };
    }();
    internals.c1Controls = function() {
      const lookup = new Array(256);
      lookup.fill(false);
      for (let i = 127; i < 160; ++i) {
        lookup[i] = true;
      }
      return function(code) {
        return lookup[code];
      };
    }();
    internals.regex = {
      ipV4: /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipV6: /^[a-fA-F\d]{0,4}$/
    };
    internals.normalizeSupportsNul = "\0".normalize("NFC") === "\0";
    internals.nulNormalize = function(email) {
      return email.split("\0").map((part) => part.normalize("NFC")).join("\0");
    };
    internals.normalize = function(email) {
      return email.normalize("NFC");
    };
    if (!internals.normalizeSupportsNul) {
      internals.normalize = function(email) {
        if (email.indexOf("\0") >= 0) {
          return internals.nulNormalize(email);
        }
        return email.normalize("NFC");
      };
    }
    internals.checkIpV6 = function(items) {
      return items.every((value) => internals.regex.ipV6.test(value));
    };
    internals.isIterable = Array.isArray;
    if (typeof Symbol !== "undefined") {
      internals.isIterable = (value) => Array.isArray(value) || !!value && typeof value === "object" && typeof value[Symbol.iterator] === "function";
    }
    internals._isSet = (value) => value instanceof Set;
    internals._isMap = (value) => value instanceof Map;
    internals.isSet = Util.types && Util.types.isSet || internals._isSet;
    internals.isMap = Util.types && Util.types.isMap || internals._isMap;
    internals.normalizeTable = function(table) {
      if (internals.isSet(table) || Array.isArray(table)) {
        return table;
      }
      if (internals.isMap(table)) {
        return table.keys();
      }
      return Object.keys(table);
    };
    internals.canonicalizeAtom = function(atom) {
      return Punycode.toASCII(atom).toLowerCase();
    };
    internals.includesMapped = function(iterable, iteratee, value) {
      for (const item of iterable) {
        if (value === iteratee(item)) {
          return true;
        }
      }
      return false;
    };
    internals.validDomain = function(tldAtom, options) {
      const canonicalTldAtom = internals.canonicalizeAtom(tldAtom);
      if (options.tldBlacklist) {
        return !internals.includesMapped(
          internals.normalizeTable(options.tldBlacklist),
          internals.canonicalizeAtom,
          canonicalTldAtom
        );
      }
      return internals.includesMapped(
        internals.normalizeTable(options.tldWhitelist),
        internals.canonicalizeAtom,
        canonicalTldAtom
      );
    };
    internals.hasDomainLiteralThenAtom = function(domainAtoms) {
      let hasDomainLiteral = false;
      for (let i = 0; i < domainAtoms.length; ++i) {
        if (domainAtoms[i][0] === "[") {
          hasDomainLiteral = true;
        } else if (hasDomainLiteral) {
          return true;
        }
      }
      return false;
    };
    exports.validate = internals.validate = function(email, options, callback) {
      options = options || {};
      if (typeof email !== "string") {
        throw new TypeError("expected string email");
      }
      email = internals.normalize(email);
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (typeof callback !== "function") {
        callback = null;
      }
      let diagnose;
      let threshold;
      if (typeof options.errorLevel === "number") {
        diagnose = true;
        threshold = options.errorLevel;
      } else {
        diagnose = !!options.errorLevel;
        threshold = internals.diagnoses.valid;
      }
      if (options.tldWhitelist) {
        if (typeof options.tldWhitelist === "string") {
          options.tldWhitelist = [options.tldWhitelist];
        } else if (typeof options.tldWhitelist !== "object") {
          throw new TypeError("expected array or object tldWhitelist");
        }
      }
      if (options.tldBlacklist) {
        if (typeof options.tldBlacklist === "string") {
          options.tldBlacklist = [options.tldBlacklist];
        } else if (typeof options.tldBlacklist !== "object") {
          throw new TypeError("expected array or object tldBlacklist");
        }
      }
      if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {
        throw new TypeError("expected positive integer minDomainAtoms");
      }
      if (options.excludeDiagnoses) {
        if (!internals.isIterable(options.excludeDiagnoses)) {
          throw new TypeError("expected iterable excludeDiagnoses");
        }
        if (!internals.isSet(options.excludeDiagnoses)) {
          options.excludeDiagnoses = new Set(options.excludeDiagnoses);
        }
      }
      let maxResult = internals.diagnoses.valid;
      const updateResult = (value) => {
        if (value > maxResult && (!options.excludeDiagnoses || !options.excludeDiagnoses.has(value))) {
          maxResult = value;
        }
      };
      const allowUnicode = options.allowUnicode === void 0 || !!options.allowUnicode;
      if (!allowUnicode && /[^\x00-\x7f]/.test(email)) {
        updateResult(internals.diagnoses.undesiredNonAscii);
      }
      const context = {
        now: internals.components.localpart,
        prev: internals.components.localpart,
        stack: [internals.components.localpart]
      };
      let prevToken = "";
      const parseData = {
        local: "",
        domain: ""
      };
      const atomData = {
        locals: [""],
        domains: [""]
      };
      let elementCount = 0;
      let elementLength = 0;
      let crlfCount = 0;
      let charCode;
      let hyphenFlag = false;
      let assertEnd = false;
      const emailLength = email.length;
      let token;
      for (let i = 0; i < emailLength; i += token.length) {
        token = String.fromCodePoint(email.codePointAt(i));
        switch (context.now) {
          case internals.components.localpart:
            switch (token) {
              case "(":
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);
                } else {
                  updateResult(internals.diagnoses.cfwsComment);
                  assertEnd = true;
                }
                context.stack.push(context.now);
                context.now = internals.components.contextComment;
                break;
              case ".":
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                } else {
                  if (assertEnd) {
                    updateResult(internals.diagnoses.deprecatedLocalPart);
                  }
                  assertEnd = false;
                  elementLength = 0;
                  ++elementCount;
                  parseData.local += token;
                  atomData.locals[elementCount] = "";
                }
                break;
              case '"':
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);
                  parseData.local += token;
                  atomData.locals[elementCount] += token;
                  elementLength += Buffer.byteLength(token, "utf8");
                  assertEnd = true;
                  context.stack.push(context.now);
                  context.now = internals.components.contextQuotedString;
                } else {
                  updateResult(internals.diagnoses.errExpectingATEXT);
                }
                break;
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                  break;
                }
              case " ":
              case "	":
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);
                } else {
                  assertEnd = true;
                }
                context.stack.push(context.now);
                context.now = internals.components.contextFWS;
                prevToken = token;
                break;
              case "@":
                if (context.stack.length !== 1) {
                  throw new Error("unexpected item on context stack");
                }
                if (parseData.local.length === 0) {
                  updateResult(internals.diagnoses.errNoLocalPart);
                } else if (elementLength === 0) {
                  updateResult(internals.diagnoses.errDotEnd);
                } else if (Buffer.byteLength(parseData.local, "utf8") > 64) {
                  updateResult(internals.diagnoses.rfc5322LocalTooLong);
                } else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {
                  updateResult(internals.diagnoses.deprecatedCFWSNearAt);
                }
                context.now = internals.components.domain;
                context.stack[0] = internals.components.domain;
                elementCount = 0;
                elementLength = 0;
                assertEnd = false;
                break;
              default:
                if (assertEnd) {
                  switch (context.prev) {
                    case internals.components.contextComment:
                    case internals.components.contextFWS:
                      updateResult(internals.diagnoses.errATEXTAfterCFWS);
                      break;
                    case internals.components.contextQuotedString:
                      updateResult(internals.diagnoses.errATEXTAfterQS);
                      break;
                    default:
                      throw new Error("more atext found where none is allowed, but unrecognized prev context: " + context.prev);
                  }
                } else {
                  context.prev = context.now;
                  charCode = token.codePointAt(0);
                  if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {
                    updateResult(internals.diagnoses.errExpectingATEXT);
                  }
                  parseData.local += token;
                  atomData.locals[elementCount] += token;
                  elementLength += Buffer.byteLength(token, "utf8");
                }
            }
            break;
          case internals.components.domain:
            switch (token) {
              case "(":
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);
                } else {
                  assertEnd = true;
                  updateResult(internals.diagnoses.cfwsComment);
                }
                context.stack.push(context.now);
                context.now = internals.components.contextComment;
                break;
              case ".":
                const punycodeLength = Punycode.toASCII(atomData.domains[elementCount]).length;
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                } else if (hyphenFlag) {
                  updateResult(internals.diagnoses.errDomainHyphenEnd);
                } else if (punycodeLength > 63) {
                  updateResult(internals.diagnoses.rfc5322LabelTooLong);
                }
                assertEnd = false;
                elementLength = 0;
                ++elementCount;
                atomData.domains[elementCount] = "";
                parseData.domain += token;
                break;
              case "[":
                if (atomData.domains[elementCount].length === 0) {
                  if (parseData.domain.length) {
                    updateResult(internals.diagnoses.errDotAfterDomainLiteral);
                  }
                  assertEnd = true;
                  elementLength += Buffer.byteLength(token, "utf8");
                  context.stack.push(context.now);
                  context.now = internals.components.literal;
                  parseData.domain += token;
                  atomData.domains[elementCount] += token;
                  parseData.literal = "";
                } else {
                  updateResult(internals.diagnoses.errExpectingATEXT);
                }
                break;
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                  break;
                }
              case " ":
              case "	":
                if (elementLength === 0) {
                  updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);
                } else {
                  updateResult(internals.diagnoses.cfwsFWS);
                  assertEnd = true;
                }
                context.stack.push(context.now);
                context.now = internals.components.contextFWS;
                prevToken = token;
                break;
              default:
                if (assertEnd) {
                  switch (context.prev) {
                    case internals.components.contextComment:
                    case internals.components.contextFWS:
                      updateResult(internals.diagnoses.errATEXTAfterCFWS);
                      break;
                    case internals.components.literal:
                      updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);
                      break;
                    default:
                      throw new Error("more atext found where none is allowed, but unrecognized prev context: " + context.prev);
                  }
                }
                charCode = token.codePointAt(0);
                hyphenFlag = false;
                if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {
                  updateResult(internals.diagnoses.errExpectingATEXT);
                } else if (token === "-") {
                  if (elementLength === 0) {
                    updateResult(internals.diagnoses.errDomainHyphenStart);
                  }
                  hyphenFlag = true;
                } else if (charCode < 48 || charCode > 122 && charCode < 192 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {
                  updateResult(internals.diagnoses.rfc5322Domain);
                }
                parseData.domain += token;
                atomData.domains[elementCount] += token;
                elementLength += Buffer.byteLength(token, "utf8");
            }
            break;
          case internals.components.literal:
            switch (token) {
              case "]":
                if (maxResult < internals.categories.deprecated) {
                  let index = -1;
                  let addressLiteral = parseData.literal;
                  const matchesIP = internals.regex.ipV4.exec(addressLiteral);
                  if (matchesIP) {
                    index = matchesIP.index;
                    if (index !== 0) {
                      addressLiteral = addressLiteral.slice(0, index) + "0:0";
                    }
                  }
                  if (index === 0) {
                    updateResult(internals.diagnoses.rfc5321AddressLiteral);
                  } else if (addressLiteral.slice(0, 5).toLowerCase() !== "ipv6:") {
                    updateResult(internals.diagnoses.rfc5322DomainLiteral);
                  } else {
                    const match = addressLiteral.slice(5);
                    let maxGroups = internals.maxIPv6Groups;
                    const groups = match.split(":");
                    index = match.indexOf("::");
                    if (!~index) {
                      if (groups.length !== maxGroups) {
                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);
                      }
                    } else if (index !== match.lastIndexOf("::")) {
                      updateResult(internals.diagnoses.rfc5322IPv62x2xColon);
                    } else {
                      if (index === 0 || index === match.length - 2) {
                        ++maxGroups;
                      }
                      if (groups.length > maxGroups) {
                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);
                      } else if (groups.length === maxGroups) {
                        updateResult(internals.diagnoses.deprecatedIPv6);
                      }
                    }
                    if (match[0] === ":" && match[1] !== ":") {
                      updateResult(internals.diagnoses.rfc5322IPv6ColonStart);
                    } else if (match[match.length - 1] === ":" && match[match.length - 2] !== ":") {
                      updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);
                    } else if (internals.checkIpV6(groups)) {
                      updateResult(internals.diagnoses.rfc5321AddressLiteral);
                    } else {
                      updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);
                    }
                  }
                } else {
                  updateResult(internals.diagnoses.rfc5322DomainLiteral);
                }
                parseData.domain += token;
                atomData.domains[elementCount] += token;
                elementLength += Buffer.byteLength(token, "utf8");
                context.prev = context.now;
                context.now = context.stack.pop();
                break;
              case "\\":
                updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                context.stack.push(context.now);
                context.now = internals.components.contextQuotedPair;
                break;
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                  break;
                }
              case " ":
              case "	":
                updateResult(internals.diagnoses.cfwsFWS);
                context.stack.push(context.now);
                context.now = internals.components.contextFWS;
                prevToken = token;
                break;
              default:
                charCode = token.codePointAt(0);
                if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || token === "[") {
                  updateResult(internals.diagnoses.errExpectingDTEXT);
                  break;
                } else if (internals.c0Controls(charCode) || charCode === 127) {
                  updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                }
                parseData.literal += token;
                parseData.domain += token;
                atomData.domains[elementCount] += token;
                elementLength += Buffer.byteLength(token, "utf8");
            }
            break;
          case internals.components.contextQuotedString:
            switch (token) {
              case "\\":
                context.stack.push(context.now);
                context.now = internals.components.contextQuotedPair;
                break;
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                  break;
                }
              case "	":
                parseData.local += " ";
                atomData.locals[elementCount] += " ";
                elementLength += Buffer.byteLength(token, "utf8");
                updateResult(internals.diagnoses.cfwsFWS);
                context.stack.push(context.now);
                context.now = internals.components.contextFWS;
                prevToken = token;
                break;
              case '"':
                parseData.local += token;
                atomData.locals[elementCount] += token;
                elementLength += Buffer.byteLength(token, "utf8");
                context.prev = context.now;
                context.now = context.stack.pop();
                break;
              default:
                charCode = token.codePointAt(0);
                if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || charCode === 10) {
                  updateResult(internals.diagnoses.errExpectingQTEXT);
                } else if (internals.c0Controls(charCode) || charCode === 127) {
                  updateResult(internals.diagnoses.deprecatedQTEXT);
                }
                parseData.local += token;
                atomData.locals[elementCount] += token;
                elementLength += Buffer.byteLength(token, "utf8");
            }
            break;
          case internals.components.contextQuotedPair:
            charCode = token.codePointAt(0);
            if (charCode !== 127 && internals.c1Controls(charCode)) {
              updateResult(internals.diagnoses.errExpectingQPair);
            } else if (charCode < 31 && charCode !== 9 || charCode === 127) {
              updateResult(internals.diagnoses.deprecatedQP);
            }
            context.prev = context.now;
            context.now = context.stack.pop();
            const escapeToken = "\\" + token;
            switch (context.now) {
              case internals.components.contextComment:
                break;
              case internals.components.contextQuotedString:
                parseData.local += escapeToken;
                atomData.locals[elementCount] += escapeToken;
                elementLength += 2;
                break;
              case internals.components.literal:
                parseData.domain += escapeToken;
                atomData.domains[elementCount] += escapeToken;
                elementLength += 2;
                break;
              default:
                throw new Error("quoted pair logic invoked in an invalid context: " + context.now);
            }
            break;
          case internals.components.contextComment:
            switch (token) {
              case "(":
                context.stack.push(context.now);
                context.now = internals.components.contextComment;
                break;
              case ")":
                context.prev = context.now;
                context.now = context.stack.pop();
                break;
              case "\\":
                context.stack.push(context.now);
                context.now = internals.components.contextQuotedPair;
                break;
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                  break;
                }
              case " ":
              case "	":
                updateResult(internals.diagnoses.cfwsFWS);
                context.stack.push(context.now);
                context.now = internals.components.contextFWS;
                prevToken = token;
                break;
              default:
                charCode = token.codePointAt(0);
                if (charCode === 0 || charCode === 10 || charCode !== 127 && internals.c1Controls(charCode)) {
                  updateResult(internals.diagnoses.errExpectingCTEXT);
                  break;
                } else if (internals.c0Controls(charCode) || charCode === 127) {
                  updateResult(internals.diagnoses.deprecatedCTEXT);
                }
            }
            break;
          case internals.components.contextFWS:
            if (prevToken === "\r") {
              if (token === "\r") {
                updateResult(internals.diagnoses.errFWSCRLFx2);
                break;
              }
              if (++crlfCount > 1) {
                updateResult(internals.diagnoses.deprecatedFWS);
              } else {
                crlfCount = 1;
              }
            }
            switch (token) {
              case "\r":
                if (emailLength === ++i || email[i] !== "\n") {
                  updateResult(internals.diagnoses.errCRNoLF);
                }
                break;
              case " ":
              case "	":
                break;
              default:
                if (prevToken === "\r") {
                  updateResult(internals.diagnoses.errFWSCRLFEnd);
                }
                crlfCount = 0;
                context.prev = context.now;
                context.now = context.stack.pop();
                --i;
            }
            prevToken = token;
            break;
          default:
            throw new Error("unknown context: " + context.now);
        }
        if (maxResult > internals.categories.rfc5322) {
          break;
        }
      }
      if (maxResult < internals.categories.rfc5322) {
        const punycodeLength = Punycode.toASCII(parseData.domain).length;
        if (context.now === internals.components.contextQuotedString) {
          updateResult(internals.diagnoses.errUnclosedQuotedString);
        } else if (context.now === internals.components.contextQuotedPair) {
          updateResult(internals.diagnoses.errBackslashEnd);
        } else if (context.now === internals.components.contextComment) {
          updateResult(internals.diagnoses.errUnclosedComment);
        } else if (context.now === internals.components.literal) {
          updateResult(internals.diagnoses.errUnclosedDomainLiteral);
        } else if (token === "\r") {
          updateResult(internals.diagnoses.errFWSCRLFEnd);
        } else if (parseData.domain.length === 0) {
          updateResult(internals.diagnoses.errNoDomain);
        } else if (elementLength === 0) {
          updateResult(internals.diagnoses.errDotEnd);
        } else if (hyphenFlag) {
          updateResult(internals.diagnoses.errDomainHyphenEnd);
        } else if (punycodeLength > 255) {
          updateResult(internals.diagnoses.rfc5322DomainTooLong);
        } else if (Buffer.byteLength(parseData.local, "utf8") + punycodeLength + /* '@' */
        1 > 254) {
          updateResult(internals.diagnoses.rfc5322TooLong);
        } else if (elementLength > 63) {
          updateResult(internals.diagnoses.rfc5322LabelTooLong);
        } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms && (atomData.domains.length !== 1 || atomData.domains[0][0] !== "[")) {
          updateResult(internals.diagnoses.errDomainTooShort);
        } else if (internals.hasDomainLiteralThenAtom(atomData.domains)) {
          updateResult(internals.diagnoses.errDotAfterDomainLiteral);
        } else if (options.tldWhitelist || options.tldBlacklist) {
          const tldAtom = atomData.domains[elementCount];
          if (!internals.validDomain(tldAtom, options)) {
            updateResult(internals.diagnoses.errUnknownTLD);
          }
        }
      }
      if (maxResult < internals.categories.dnsWarn) {
        const code = atomData.domains[elementCount].codePointAt(0);
        if (code <= 57) {
          updateResult(internals.diagnoses.rfc5321TLDNumeric);
        }
      }
      if (maxResult < threshold) {
        maxResult = internals.diagnoses.valid;
      }
      const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;
      if (callback) {
        callback(finishResult);
      }
      return finishResult;
    };
    exports.diagnoses = internals.validate.diagnoses = function() {
      const diag = {};
      const keys = Object.keys(internals.diagnoses);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        diag[key] = internals.diagnoses[key];
      }
      return diag;
    }();
    exports.normalize = internals.normalize;
  }
});

// ../../../node_modules/joi/lib/types/string/index.js
var require_string = __commonJS({
  "../../../node_modules/joi/lib/types/string/index.js"(exports, module) {
    "use strict";
    var Net = require_net();
    var Hoek = require_lib();
    var Isemail;
    var Any = require_any();
    var Ref = require_ref();
    var JoiDate = require_date();
    var Uri = require_uri();
    var Ip = require_ip();
    var internals = {
      uriRegex: Uri.createUriRegex(),
      ipRegex: Ip.createIpRegex(["ipv4", "ipv6", "ipvfuture"], "optional"),
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5"
      },
      cidrPresences: ["required", "optional", "forbidden"],
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    internals.String = class extends Any {
      constructor() {
        super();
        this._type = "string";
        this._invalids.add("");
      }
      _base(value, state, options) {
        if (typeof value === "string" && options.convert) {
          if (this._flags.normalize) {
            value = value.normalize(this._flags.normalize);
          }
          if (this._flags.case) {
            value = this._flags.case === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          if (this._flags.trim) {
            value = value.trim();
          }
          if (this._inner.replacements) {
            for (let i = 0; i < this._inner.replacements.length; ++i) {
              const replacement = this._inner.replacements[i];
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          if (this._flags.truncate) {
            for (let i = 0; i < this._tests.length; ++i) {
              const test = this._tests[i];
              if (test.name === "max") {
                value = value.slice(0, test.arg);
                break;
              }
            }
          }
        }
        return {
          value,
          errors: typeof value === "string" ? null : this.createError("string.base", { value }, state, options)
        };
      }
      insensitive() {
        if (this._flags.insensitive) {
          return this;
        }
        const obj = this.clone();
        obj._flags.insensitive = true;
        return obj;
      }
      creditCard() {
        return this._test("creditCard", void 0, function(value, state, options) {
          let i = value.length;
          let sum = 0;
          let mul = 1;
          while (i--) {
            const char = value.charAt(i) * mul;
            sum = sum + (char - (char > 9) * 9);
            mul = mul ^ 3;
          }
          const check = sum % 10 === 0 && sum > 0;
          return check ? value : this.createError("string.creditCard", { value }, state, options);
        });
      }
      regex(pattern, patternOptions) {
        Hoek.assert(pattern instanceof RegExp, "pattern must be a RegExp");
        const patternObject = {
          pattern: new RegExp(pattern.source, pattern.ignoreCase ? "i" : void 0)
          // Future version should break this and forbid unsupported regex flags
        };
        if (typeof patternOptions === "string") {
          patternObject.name = patternOptions;
        } else if (typeof patternOptions === "object") {
          patternObject.invert = !!patternOptions.invert;
          if (patternOptions.name) {
            patternObject.name = patternOptions.name;
          }
        }
        const errorCode = ["string.regex", patternObject.invert ? ".invert" : "", patternObject.name ? ".name" : ".base"].join("");
        return this._test("regex", patternObject, function(value, state, options) {
          const patternMatch = patternObject.pattern.test(value);
          if (patternMatch ^ patternObject.invert) {
            return value;
          }
          return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);
        });
      }
      alphanum() {
        return this._test("alphanum", void 0, function(value, state, options) {
          if (/^[a-zA-Z0-9]+$/.test(value)) {
            return value;
          }
          return this.createError("string.alphanum", { value }, state, options);
        });
      }
      token() {
        return this._test("token", void 0, function(value, state, options) {
          if (/^\w+$/.test(value)) {
            return value;
          }
          return this.createError("string.token", { value }, state, options);
        });
      }
      email(isEmailOptions) {
        if (isEmailOptions) {
          Hoek.assert(typeof isEmailOptions === "object", "email options must be an object");
          Hoek.assert(typeof isEmailOptions.checkDNS === "undefined", "checkDNS option is not supported");
          Hoek.assert(typeof isEmailOptions.tldWhitelist === "undefined" || typeof isEmailOptions.tldWhitelist === "object", "tldWhitelist must be an array or object");
          Hoek.assert(
            typeof isEmailOptions.minDomainAtoms === "undefined" || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,
            "minDomainAtoms must be a positive integer"
          );
          Hoek.assert(
            typeof isEmailOptions.errorLevel === "undefined" || typeof isEmailOptions.errorLevel === "boolean" || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0,
            "errorLevel must be a non-negative integer or boolean"
          );
        }
        return this._test("email", isEmailOptions, function(value, state, options) {
          Isemail = Isemail || require_lib4();
          try {
            const result = Isemail.validate(value, isEmailOptions);
            if (result === true || result === 0) {
              return value;
            }
          } catch (e) {
          }
          return this.createError("string.email", { value }, state, options);
        });
      }
      ip(ipOptions = {}) {
        let regex = internals.ipRegex;
        Hoek.assert(typeof ipOptions === "object", "options must be an object");
        if (ipOptions.cidr) {
          Hoek.assert(typeof ipOptions.cidr === "string", "cidr must be a string");
          ipOptions.cidr = ipOptions.cidr.toLowerCase();
          Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), "cidr must be one of " + internals.cidrPresences.join(", "));
          if (!ipOptions.version && ipOptions.cidr !== "optional") {
            regex = Ip.createIpRegex(["ipv4", "ipv6", "ipvfuture"], ipOptions.cidr);
          }
        } else {
          ipOptions.cidr = "optional";
        }
        let versions;
        if (ipOptions.version) {
          if (!Array.isArray(ipOptions.version)) {
            ipOptions.version = [ipOptions.version];
          }
          Hoek.assert(ipOptions.version.length >= 1, "version must have at least 1 version specified");
          versions = [];
          for (let i = 0; i < ipOptions.version.length; ++i) {
            let version = ipOptions.version[i];
            Hoek.assert(typeof version === "string", "version at position " + i + " must be a string");
            version = version.toLowerCase();
            Hoek.assert(Ip.versions[version], "version at position " + i + " must be one of " + Object.keys(Ip.versions).join(", "));
            versions.push(version);
          }
          versions = Hoek.unique(versions);
          regex = Ip.createIpRegex(versions, ipOptions.cidr);
        }
        return this._test("ip", ipOptions, function(value, state, options) {
          if (regex.test(value)) {
            return value;
          }
          if (versions) {
            return this.createError("string.ipVersion", { value, cidr: ipOptions.cidr, version: versions }, state, options);
          }
          return this.createError("string.ip", { value, cidr: ipOptions.cidr }, state, options);
        });
      }
      uri(uriOptions) {
        let customScheme = "";
        let allowRelative = false;
        let relativeOnly = false;
        let regex = internals.uriRegex;
        if (uriOptions) {
          Hoek.assert(typeof uriOptions === "object", "options must be an object");
          if (uriOptions.scheme) {
            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === "string" || Array.isArray(uriOptions.scheme), "scheme must be a RegExp, String, or Array");
            if (!Array.isArray(uriOptions.scheme)) {
              uriOptions.scheme = [uriOptions.scheme];
            }
            Hoek.assert(uriOptions.scheme.length >= 1, "scheme must have at least 1 scheme specified");
            for (let i = 0; i < uriOptions.scheme.length; ++i) {
              const scheme = uriOptions.scheme[i];
              Hoek.assert(scheme instanceof RegExp || typeof scheme === "string", "scheme at position " + i + " must be a RegExp or String");
              customScheme = customScheme + (customScheme ? "|" : "");
              if (scheme instanceof RegExp) {
                customScheme = customScheme + scheme.source;
              } else {
                Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), "scheme at position " + i + " must be a valid scheme");
                customScheme = customScheme + Hoek.escapeRegex(scheme);
              }
            }
          }
          if (uriOptions.allowRelative) {
            allowRelative = true;
          }
          if (uriOptions.relativeOnly) {
            relativeOnly = true;
          }
        }
        if (customScheme || allowRelative || relativeOnly) {
          regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly);
        }
        return this._test("uri", uriOptions, function(value, state, options) {
          if (regex.test(value)) {
            return value;
          }
          if (relativeOnly) {
            return this.createError("string.uriRelativeOnly", { value }, state, options);
          }
          if (customScheme) {
            return this.createError("string.uriCustomScheme", { scheme: customScheme, value }, state, options);
          }
          return this.createError("string.uri", { value }, state, options);
        });
      }
      isoDate() {
        return this._test("isoDate", void 0, function(value, state, options) {
          if (JoiDate._isIsoDate(value)) {
            if (!options.convert) {
              return value;
            }
            const d = new Date(value);
            if (!isNaN(d.getTime())) {
              return d.toISOString();
            }
          }
          return this.createError("string.isoDate", { value }, state, options);
        });
      }
      guid(guidOptions) {
        let versionNumbers = "";
        if (guidOptions && guidOptions.version) {
          if (!Array.isArray(guidOptions.version)) {
            guidOptions.version = [guidOptions.version];
          }
          Hoek.assert(guidOptions.version.length >= 1, "version must have at least 1 valid version specified");
          const versions = /* @__PURE__ */ new Set();
          for (let i = 0; i < guidOptions.version.length; ++i) {
            let version = guidOptions.version[i];
            Hoek.assert(typeof version === "string", "version at position " + i + " must be a string");
            version = version.toLowerCase();
            const versionNumber = internals.guidVersions[version];
            Hoek.assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
            Hoek.assert(!versions.has(versionNumber), "version at position " + i + " must not be a duplicate.");
            versionNumbers += versionNumber;
            versions.add(versionNumber);
          }
        }
        const guidRegex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
        return this._test("guid", guidOptions, function(value, state, options) {
          const results = guidRegex.exec(value);
          if (!results) {
            return this.createError("string.guid", { value }, state, options);
          }
          if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
            return this.createError("string.guid", { value }, state, options);
          }
          return value;
        });
      }
      hex() {
        const regex = /^[a-f0-9]+$/i;
        return this._test("hex", regex, function(value, state, options) {
          if (regex.test(value)) {
            return value;
          }
          return this.createError("string.hex", { value }, state, options);
        });
      }
      base64(base64Options = {}) {
        Hoek.assert(typeof base64Options === "object", "base64 options must be an object");
        Hoek.assert(
          typeof base64Options.paddingRequired === "undefined" || typeof base64Options.paddingRequired === "boolean",
          "paddingRequired must be boolean"
        );
        const paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true;
        const regex = paddingRequired ? (
          // Padding is required.
          /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        ) : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;
        return this._test("base64", regex, function(value, state, options) {
          if (regex.test(value)) {
            return value;
          }
          return this.createError("string.base64", { value }, state, options);
        });
      }
      hostname() {
        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
        return this._test("hostname", void 0, function(value, state, options) {
          if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {
            return value;
          }
          return this.createError("string.hostname", { value }, state, options);
        });
      }
      normalize(form = "NFC") {
        Hoek.assert(Hoek.contain(internals.normalizationForms, form), "normalization form must be one of " + internals.normalizationForms.join(", "));
        const obj = this._test("normalize", form, function(value, state, options) {
          if (options.convert || value === value.normalize(form)) {
            return value;
          }
          return this.createError("string.normalize", { value, form }, state, options);
        });
        obj._flags.normalize = form;
        return obj;
      }
      lowercase() {
        const obj = this._test("lowercase", void 0, function(value, state, options) {
          if (options.convert || value === value.toLocaleLowerCase()) {
            return value;
          }
          return this.createError("string.lowercase", { value }, state, options);
        });
        obj._flags.case = "lower";
        return obj;
      }
      uppercase() {
        const obj = this._test("uppercase", void 0, function(value, state, options) {
          if (options.convert || value === value.toLocaleUpperCase()) {
            return value;
          }
          return this.createError("string.uppercase", { value }, state, options);
        });
        obj._flags.case = "upper";
        return obj;
      }
      trim() {
        const obj = this._test("trim", void 0, function(value, state, options) {
          if (options.convert || value === value.trim()) {
            return value;
          }
          return this.createError("string.trim", { value }, state, options);
        });
        obj._flags.trim = true;
        return obj;
      }
      replace(pattern, replacement) {
        if (typeof pattern === "string") {
          pattern = new RegExp(Hoek.escapeRegex(pattern), "g");
        }
        Hoek.assert(pattern instanceof RegExp, "pattern must be a RegExp");
        Hoek.assert(typeof replacement === "string", "replacement must be a String");
        const obj = this.clone();
        if (!obj._inner.replacements) {
          obj._inner.replacements = [];
        }
        obj._inner.replacements.push({
          pattern,
          replacement
        });
        return obj;
      }
      truncate(enabled) {
        const value = enabled === void 0 ? true : !!enabled;
        if (this._flags.truncate === value) {
          return this;
        }
        const obj = this.clone();
        obj._flags.truncate = value;
        return obj;
      }
    };
    internals.compare = function(type, compare) {
      return function(limit, encoding) {
        const isRef = Ref.isRef(limit);
        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
        return this._test(type, limit, function(value, state, options) {
          let compareTo;
          if (isRef) {
            compareTo = limit(state.reference || state.parent, options);
            if (!Number.isSafeInteger(compareTo)) {
              return this.createError("string.ref", { ref: limit.key }, state, options);
            }
          } else {
            compareTo = limit;
          }
          if (compare(value, compareTo, encoding)) {
            return value;
          }
          return this.createError("string." + type, { limit: compareTo, value, encoding }, state, options);
        });
      };
    };
    internals.String.prototype.min = internals.compare("min", (value, limit, encoding) => {
      const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
      return length >= limit;
    });
    internals.String.prototype.max = internals.compare("max", (value, limit, encoding) => {
      const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
      return length <= limit;
    });
    internals.String.prototype.length = internals.compare("length", (value, limit, encoding) => {
      const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
      return length === limit;
    });
    internals.String.prototype.uuid = internals.String.prototype.guid;
    module.exports = new internals.String();
  }
});

// ../../../node_modules/joi/package.json
var require_package = __commonJS({
  "../../../node_modules/joi/package.json"(exports, module) {
    module.exports = {
      _from: "joi@13.1.0",
      _id: "joi@13.1.0",
      _inBundle: false,
      _integrity: "sha512-x6pGmDYI6hwNi3skP6irQqRaJntzeaWmZ4rsnjc/NTlf6P5Gp3Aw/O8REe8oLJ6wPhrzd9K3RW1m3Yz/Hx4Weg==",
      _location: "/joi",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "joi@13.1.0",
        name: "joi",
        escapedName: "joi",
        rawSpec: "13.1.0",
        saveSpec: null,
        fetchSpec: "13.1.0"
      },
      _requiredBy: [
        "#USER",
        "/"
      ],
      _resolved: "https://registry.npmjs.org/joi/-/joi-13.1.0.tgz",
      _shasum: "59e7b8714b932a1e342c3583d5841d7169ff1822",
      _spec: "joi@13.1.0",
      _where: "C:\\Users\\paulo\\Documents\\npm-course",
      bugs: {
        url: "https://github.com/hapijs/joi/issues"
      },
      bundleDependencies: false,
      dependencies: {
        hoek: "5.x.x",
        isemail: "3.x.x",
        topo: "3.x.x"
      },
      deprecated: "This version has been deprecated in accordance with the hapi support policy (hapi.im/support). Please upgrade to the latest version to get the best features, bug fixes, and security patches. If you are unable to upgrade at this time, paid support is available for older versions (hapi.im/commercial).",
      description: "Object schema validation",
      devDependencies: {
        code: "5.x.x",
        hapitoc: "1.x.x",
        lab: "15.x.x"
      },
      engines: {
        node: ">=8.9.0"
      },
      homepage: "https://github.com/hapijs/joi",
      keywords: [
        "hapi",
        "schema",
        "validation"
      ],
      license: "BSD-3-Clause",
      main: "lib/index.js",
      name: "joi",
      repository: {
        type: "git",
        url: "git://github.com/hapijs/joi.git"
      },
      scripts: {
        test: "lab -t 100 -a code -L",
        "test-cov-html": "lab -r html -o coverage.html -a code",
        "test-debug": "lab -a code",
        toc: "hapitoc",
        version: "npm run toc && git add API.md README.md"
      },
      version: "13.1.0"
    };
  }
});

// ../../../node_modules/joi/lib/index.js
var require_lib5 = __commonJS({
  "../../../node_modules/joi/lib/index.js"(exports, module) {
    "use strict";
    var Hoek = require_lib();
    var Any = require_any();
    var Cast = require_cast();
    var Errors = require_errors();
    var Lazy = require_lazy();
    var Ref = require_ref();
    var internals = {
      alternatives: require_alternatives(),
      array: require_array(),
      boolean: require_boolean(),
      binary: require_binary(),
      date: require_date(),
      func: require_func(),
      number: require_number(),
      object: require_object(),
      string: require_string()
    };
    internals.applyDefaults = function(schema) {
      Hoek.assert(this, "Must be invoked on a Joi instance.");
      if (this._defaults) {
        schema = this._defaults(schema);
      }
      schema._currentJoi = this;
      return schema;
    };
    internals.root = function() {
      const any = new Any();
      const root = any.clone();
      Any.prototype._currentJoi = root;
      root._currentJoi = root;
      root.any = function(...args) {
        Hoek.assert(args.length === 0, "Joi.any() does not allow arguments.");
        return internals.applyDefaults.call(this, any);
      };
      root.alternatives = root.alt = function(...args) {
        const alternatives = internals.applyDefaults.call(this, internals.alternatives);
        return args.length ? alternatives.try.apply(alternatives, args) : alternatives;
      };
      root.array = function(...args) {
        Hoek.assert(args.length === 0, "Joi.array() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.array);
      };
      root.boolean = root.bool = function(...args) {
        Hoek.assert(args.length === 0, "Joi.boolean() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.boolean);
      };
      root.binary = function(...args) {
        Hoek.assert(args.length === 0, "Joi.binary() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.binary);
      };
      root.date = function(...args) {
        Hoek.assert(args.length === 0, "Joi.date() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.date);
      };
      root.func = function(...args) {
        Hoek.assert(args.length === 0, "Joi.func() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.func);
      };
      root.number = function(...args) {
        Hoek.assert(args.length === 0, "Joi.number() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.number);
      };
      root.object = function(...args) {
        const object = internals.applyDefaults.call(this, internals.object);
        return args.length ? object.keys(...args) : object;
      };
      root.string = function(...args) {
        Hoek.assert(args.length === 0, "Joi.string() does not allow arguments.");
        return internals.applyDefaults.call(this, internals.string);
      };
      root.ref = function(...args) {
        return Ref.create(...args);
      };
      root.isRef = function(ref) {
        return Ref.isRef(ref);
      };
      root.validate = function(value, ...args) {
        const last = args[args.length - 1];
        const callback = typeof last === "function" ? last : null;
        const count = args.length - (callback ? 1 : 0);
        if (count === 0) {
          return any.validate(value, callback);
        }
        const options = count === 2 ? args[1] : {};
        const schema = root.compile(args[0]);
        return schema._validateWithOptions(value, options, callback);
      };
      root.describe = function(...args) {
        const schema = args.length ? root.compile(args[0]) : any;
        return schema.describe();
      };
      root.compile = function(schema) {
        try {
          return Cast.schema(this, schema);
        } catch (err) {
          if (err.hasOwnProperty("path")) {
            err.message = err.message + "(" + err.path + ")";
          }
          throw err;
        }
      };
      root.assert = function(value, schema, message) {
        root.attempt(value, schema, message);
      };
      root.attempt = function(value, schema, message) {
        const result = root.validate(value, schema);
        const error2 = result.error;
        if (error2) {
          if (!message) {
            if (typeof error2.annotate === "function") {
              error2.message = error2.annotate();
            }
            throw error2;
          }
          if (!(message instanceof Error)) {
            if (typeof error2.annotate === "function") {
              error2.message = `${message} ${error2.annotate()}`;
            }
            throw error2;
          }
          throw message;
        }
        return result.value;
      };
      root.reach = function(schema, path) {
        Hoek.assert(schema && schema instanceof Any, "you must provide a joi schema");
        Hoek.assert(typeof path === "string", "path must be a string");
        if (path === "") {
          return schema;
        }
        const parts = path.split(".");
        const children = schema._inner.children;
        if (!children) {
          return;
        }
        const key = parts[0];
        for (let i = 0; i < children.length; ++i) {
          const child = children[i];
          if (child.key === key) {
            return this.reach(child.schema, path.substr(key.length + 1));
          }
        }
      };
      root.lazy = function(fn) {
        return Lazy.set(fn);
      };
      root.defaults = function(fn) {
        Hoek.assert(typeof fn === "function", "Defaults must be a function");
        let joi = Object.create(this.any());
        joi = fn(joi);
        Hoek.assert(joi && joi instanceof this.constructor, "defaults() must return a schema");
        Object.assign(joi, this, joi.clone());
        joi._defaults = (schema) => {
          if (this._defaults) {
            schema = this._defaults(schema);
            Hoek.assert(schema instanceof this.constructor, "defaults() must return a schema");
          }
          schema = fn(schema);
          Hoek.assert(schema instanceof this.constructor, "defaults() must return a schema");
          return schema;
        };
        return joi;
      };
      root.extend = function(...args) {
        const extensions = Hoek.flatten(args);
        Hoek.assert(extensions.length > 0, "You need to provide at least one extension");
        this.assert(extensions, root.extensionsSchema);
        const joi = Object.create(this.any());
        Object.assign(joi, this);
        for (let i = 0; i < extensions.length; ++i) {
          let extension = extensions[i];
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, root.extensionSchema);
          const base2 = (extension.base || this.any()).clone();
          const ctor = base2.constructor;
          const type = class extends ctor {
            // eslint-disable-line no-loop-func
            constructor() {
              super();
              if (extension.base) {
                Object.assign(this, base2);
              }
              this._type = extension.name;
              if (extension.language) {
                this._settings = this._settings || { language: {} };
                this._settings.language = Hoek.applyToDefaults(this._settings.language, {
                  [extension.name]: extension.language
                });
              }
            }
          };
          if (extension.coerce) {
            type.prototype._coerce = function(value, state, options) {
              if (ctor.prototype._coerce) {
                const baseRet = ctor.prototype._coerce.call(this, value, state, options);
                if (baseRet.errors) {
                  return baseRet;
                }
                value = baseRet.value;
              }
              const ret = extension.coerce.call(this, value, state, options);
              if (ret instanceof Errors.Err) {
                return { value, errors: ret };
              }
              return { value: ret };
            };
          }
          if (extension.pre) {
            type.prototype._base = function(value, state, options) {
              if (ctor.prototype._base) {
                const baseRet = ctor.prototype._base.call(this, value, state, options);
                if (baseRet.errors) {
                  return baseRet;
                }
                value = baseRet.value;
              }
              const ret = extension.pre.call(this, value, state, options);
              if (ret instanceof Errors.Err) {
                return { value, errors: ret };
              }
              return { value: ret };
            };
          }
          if (extension.rules) {
            for (let j = 0; j < extension.rules.length; ++j) {
              const rule = extension.rules[j];
              const ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params) : [];
              const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;
              type.prototype[rule.name] = function(...rArgs) {
                if (rArgs.length > ruleArgs.length) {
                  throw new Error("Unexpected number of arguments");
                }
                let hasRef = false;
                let arg = {};
                for (let k = 0; k < ruleArgs.length; ++k) {
                  arg[ruleArgs[k]] = rArgs[k];
                  if (!hasRef && Ref.isRef(rArgs[k])) {
                    hasRef = true;
                  }
                }
                if (validateArgs) {
                  arg = joi.attempt(arg, validateArgs);
                }
                let schema;
                if (rule.validate) {
                  const validate = function(value, state, options) {
                    return rule.validate.call(this, arg, value, state, options);
                  };
                  schema = this._test(rule.name, arg, validate, {
                    description: rule.description,
                    hasRef
                  });
                } else {
                  schema = this.clone();
                }
                if (rule.setup) {
                  const newSchema = rule.setup.call(schema, arg);
                  if (newSchema !== void 0) {
                    Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);
                    schema = newSchema;
                  }
                }
                return schema;
              };
            }
          }
          if (extension.describe) {
            type.prototype.describe = function() {
              const description = ctor.prototype.describe.call(this);
              return extension.describe.call(this, description);
            };
          }
          const instance = new type();
          joi[extension.name] = function() {
            return internals.applyDefaults.call(this, instance);
          };
        }
        return joi;
      };
      root.extensionSchema = internals.object.keys({
        base: internals.object.type(Any, "Joi object"),
        name: internals.string.required(),
        coerce: internals.func.arity(3),
        pre: internals.func.arity(3),
        language: internals.object,
        describe: internals.func.arity(1),
        rules: internals.array.items(internals.object.keys({
          name: internals.string.required(),
          setup: internals.func.arity(1),
          validate: internals.func.arity(4),
          params: [
            internals.object.pattern(/.*/, internals.object.type(Any, "Joi object")),
            internals.object.type(internals.object.constructor, "Joi object")
          ],
          description: [internals.string, internals.func.arity(1)]
        }).or("setup", "validate"))
      }).strict();
      root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();
      root.version = require_package().version;
      return root;
    };
    module.exports = internals.root();
  }
});

// ../../../node_modules/joi/lib/schemas.js
var require_schemas = __commonJS({
  "../../../node_modules/joi/lib/schemas.js"(exports) {
    "use strict";
    var Joi = require_lib5();
    exports.options = Joi.object({
      abortEarly: Joi.boolean(),
      convert: Joi.boolean(),
      allowUnknown: Joi.boolean(),
      skipFunctions: Joi.boolean(),
      stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or("arrays", "objects")],
      language: Joi.object(),
      presence: Joi.string().only("required", "optional", "forbidden", "ignore"),
      raw: Joi.boolean(),
      context: Joi.object(),
      strip: Joi.boolean(),
      noDefaults: Joi.boolean(),
      escapeHtml: Joi.boolean()
    }).strict();
  }
});

// ../../../node_modules/joi/lib/types/any/index.js
var require_any = __commonJS({
  "../../../node_modules/joi/lib/types/any/index.js"(exports, module) {
    "use strict";
    var Hoek = require_lib();
    var Ref = require_ref();
    var Errors = require_errors();
    var Alternatives = null;
    var Cast = null;
    var internals = {
      Set: require_set()
    };
    internals.defaults = {
      abortEarly: true,
      convert: true,
      allowUnknown: false,
      skipFunctions: false,
      stripUnknown: false,
      language: {},
      presence: "optional",
      strip: false,
      noDefaults: false,
      escapeHtml: false
      // context: null
    };
    module.exports = internals.Any = class {
      constructor() {
        Cast = Cast || require_cast();
        this.isJoi = true;
        this._type = "any";
        this._settings = null;
        this._valids = new internals.Set();
        this._invalids = new internals.Set();
        this._tests = [];
        this._refs = [];
        this._flags = {
          /*
           presence: 'optional',                   // optional, required, forbidden, ignore
           allowOnly: false,
           allowUnknown: undefined,
           default: undefined,
           forbidden: false,
           encoding: undefined,
           insensitive: false,
           trim: false,
           normalize: undefined,                   // NFC, NFD, NFKC, NFKD
           case: undefined,                        // upper, lower
           empty: undefined,
           func: false,
           raw: false
           */
        };
        this._description = null;
        this._unit = null;
        this._notes = [];
        this._tags = [];
        this._examples = [];
        this._meta = [];
        this._inner = {};
      }
      get schemaType() {
        return this._type;
      }
      createError(type, context, state, options, flags = this._flags) {
        return Errors.create(type, context, state, options, flags);
      }
      createOverrideError(type, context, state, options, message, template) {
        return Errors.create(type, context, state, options, this._flags, message, template);
      }
      checkOptions(options) {
        const Schemas = require_schemas();
        const result = Schemas.options.validate(options);
        if (result.error) {
          throw new Error(result.error.details[0].message);
        }
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        obj.isJoi = true;
        obj._currentJoi = this._currentJoi;
        obj._type = this._type;
        obj._settings = internals.concatSettings(this._settings);
        obj._baseType = this._baseType;
        obj._valids = Hoek.clone(this._valids);
        obj._invalids = Hoek.clone(this._invalids);
        obj._tests = this._tests.slice();
        obj._refs = this._refs.slice();
        obj._flags = Hoek.clone(this._flags);
        obj._description = this._description;
        obj._unit = this._unit;
        obj._notes = this._notes.slice();
        obj._tags = this._tags.slice();
        obj._examples = this._examples.slice();
        obj._meta = this._meta.slice();
        obj._inner = {};
        const inners = Object.keys(this._inner);
        for (let i = 0; i < inners.length; ++i) {
          const key = inners[i];
          obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
        }
        return obj;
      }
      concat(schema) {
        Hoek.assert(schema instanceof internals.Any, "Invalid schema object");
        Hoek.assert(this._type === "any" || schema._type === "any" || schema._type === this._type, "Cannot merge type", this._type, "with another type:", schema._type);
        let obj = this.clone();
        if (this._type === "any" && schema._type !== "any") {
          const tmpObj = schema.clone();
          const keysToRestore = [
            "_settings",
            "_valids",
            "_invalids",
            "_tests",
            "_refs",
            "_flags",
            "_description",
            "_unit",
            "_notes",
            "_tags",
            "_examples",
            "_meta",
            "_inner"
          ];
          for (let i = 0; i < keysToRestore.length; ++i) {
            tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
          }
          obj = tmpObj;
        }
        obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
        obj._valids.merge(schema._valids, schema._invalids);
        obj._invalids.merge(schema._invalids, schema._valids);
        obj._tests = obj._tests.concat(schema._tests);
        obj._refs = obj._refs.concat(schema._refs);
        Hoek.merge(obj._flags, schema._flags);
        obj._description = schema._description || obj._description;
        obj._unit = schema._unit || obj._unit;
        obj._notes = obj._notes.concat(schema._notes);
        obj._tags = obj._tags.concat(schema._tags);
        obj._examples = obj._examples.concat(schema._examples);
        obj._meta = obj._meta.concat(schema._meta);
        const inners = Object.keys(schema._inner);
        const isObject = obj._type === "object";
        for (let i = 0; i < inners.length; ++i) {
          const key = inners[i];
          const source = schema._inner[key];
          if (source) {
            const target = obj._inner[key];
            if (target) {
              if (isObject && key === "children") {
                const keys = {};
                for (let j = 0; j < target.length; ++j) {
                  keys[target[j].key] = j;
                }
                for (let j = 0; j < source.length; ++j) {
                  const sourceKey = source[j].key;
                  if (keys[sourceKey] >= 0) {
                    target[keys[sourceKey]] = {
                      key: sourceKey,
                      schema: target[keys[sourceKey]].schema.concat(source[j].schema)
                    };
                  } else {
                    target.push(source[j]);
                  }
                }
              } else {
                obj._inner[key] = obj._inner[key].concat(source);
              }
            } else {
              obj._inner[key] = source.slice();
            }
          }
        }
        return obj;
      }
      _test(name, arg, func, options) {
        const obj = this.clone();
        obj._tests.push({ func, name, arg, options });
        return obj;
      }
      options(options) {
        Hoek.assert(!options.context, "Cannot override context");
        this.checkOptions(options);
        const obj = this.clone();
        obj._settings = internals.concatSettings(obj._settings, options);
        return obj;
      }
      strict(isStrict) {
        const obj = this.clone();
        obj._settings = obj._settings || {};
        obj._settings.convert = isStrict === void 0 ? false : !isStrict;
        return obj;
      }
      raw(isRaw) {
        const value = isRaw === void 0 ? true : isRaw;
        if (this._flags.raw === value) {
          return this;
        }
        const obj = this.clone();
        obj._flags.raw = value;
        return obj;
      }
      error(err) {
        Hoek.assert(err && (err instanceof Error || typeof err === "function"), "Must provide a valid Error object or a function");
        const obj = this.clone();
        obj._flags.error = err;
        return obj;
      }
      allow(...values) {
        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          Hoek.assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          obj._invalids.remove(value);
          obj._valids.add(value, obj._refs);
        }
        return obj;
      }
      valid(...values) {
        const obj = this.allow(...values);
        obj._flags.allowOnly = true;
        return obj;
      }
      invalid(...values) {
        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          Hoek.assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          obj._valids.remove(value);
          obj._invalids.add(value, obj._refs);
        }
        return obj;
      }
      required() {
        if (this._flags.presence === "required") {
          return this;
        }
        const obj = this.clone();
        obj._flags.presence = "required";
        return obj;
      }
      optional() {
        if (this._flags.presence === "optional") {
          return this;
        }
        const obj = this.clone();
        obj._flags.presence = "optional";
        return obj;
      }
      forbidden() {
        if (this._flags.presence === "forbidden") {
          return this;
        }
        const obj = this.clone();
        obj._flags.presence = "forbidden";
        return obj;
      }
      strip() {
        if (this._flags.strip) {
          return this;
        }
        const obj = this.clone();
        obj._flags.strip = true;
        return obj;
      }
      applyFunctionToChildren(children, fn, args, root) {
        children = [].concat(children);
        if (children.length !== 1 || children[0] !== "") {
          root = root ? root + "." : "";
          const extraChildren = (children[0] === "" ? children.slice(1) : children).map((child) => {
            return root + child;
          });
          throw new Error("unknown key(s) " + extraChildren.join(", "));
        }
        return this[fn].apply(this, args);
      }
      default(value, description) {
        if (typeof value === "function" && !Ref.isRef(value)) {
          if (!value.description && description) {
            value.description = description;
          }
          if (!this._flags.func) {
            Hoek.assert(typeof value.description === "string" && value.description.length > 0, "description must be provided when default value is a function");
          }
        }
        const obj = this.clone();
        obj._flags.default = value;
        Ref.push(obj._refs, value);
        return obj;
      }
      empty(schema) {
        const obj = this.clone();
        if (schema === void 0) {
          delete obj._flags.empty;
        } else {
          obj._flags.empty = Cast.schema(this._currentJoi, schema);
        }
        return obj;
      }
      when(condition, options) {
        Hoek.assert(options && typeof options === "object", "Invalid options");
        Hoek.assert(options.then !== void 0 || options.otherwise !== void 0, 'options must have at least one of "then" or "otherwise"');
        const then = options.hasOwnProperty("then") ? this.concat(Cast.schema(this._currentJoi, options.then)) : void 0;
        const otherwise = options.hasOwnProperty("otherwise") ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : void 0;
        Alternatives = Alternatives || require_alternatives();
        const alternativeOptions = { then, otherwise };
        if (Object.prototype.hasOwnProperty.call(options, "is")) {
          alternativeOptions.is = options.is;
        }
        const obj = Alternatives.when(condition, alternativeOptions);
        obj._flags.presence = "ignore";
        obj._baseType = this;
        return obj;
      }
      description(desc) {
        Hoek.assert(desc && typeof desc === "string", "Description must be a non-empty string");
        const obj = this.clone();
        obj._description = desc;
        return obj;
      }
      notes(notes) {
        Hoek.assert(notes && (typeof notes === "string" || Array.isArray(notes)), "Notes must be a non-empty string or array");
        const obj = this.clone();
        obj._notes = obj._notes.concat(notes);
        return obj;
      }
      tags(tags) {
        Hoek.assert(tags && (typeof tags === "string" || Array.isArray(tags)), "Tags must be a non-empty string or array");
        const obj = this.clone();
        obj._tags = obj._tags.concat(tags);
        return obj;
      }
      meta(meta) {
        Hoek.assert(meta !== void 0, "Meta cannot be undefined");
        const obj = this.clone();
        obj._meta = obj._meta.concat(meta);
        return obj;
      }
      example(...args) {
        Hoek.assert(args.length === 1, "Missing example");
        const value = args[0];
        const obj = this.clone();
        obj._examples.push(value);
        return obj;
      }
      unit(name) {
        Hoek.assert(name && typeof name === "string", "Unit name must be a non-empty string");
        const obj = this.clone();
        obj._unit = name;
        return obj;
      }
      _prepareEmptyValue(value) {
        if (typeof value === "string" && this._flags.trim) {
          return value.trim();
        }
        return value;
      }
      _validate(value, state, options, reference) {
        const originalValue = value;
        state = state || { key: "", path: [], parent: null, reference };
        if (this._settings) {
          options = internals.concatSettings(options, this._settings);
        }
        let errors2 = [];
        const finish = () => {
          let finalValue;
          if (value !== void 0) {
            finalValue = this._flags.raw ? originalValue : value;
          } else if (options.noDefaults) {
            finalValue = value;
          } else if (Ref.isRef(this._flags.default)) {
            finalValue = this._flags.default(state.parent, options);
          } else if (typeof this._flags.default === "function" && !(this._flags.func && !this._flags.default.description)) {
            let args;
            if (state.parent !== null && this._flags.default.length > 0) {
              args = [Hoek.clone(state.parent), options];
            }
            const defaultValue = internals._try(this._flags.default, args);
            finalValue = defaultValue.value;
            if (defaultValue.error) {
              errors2.push(this.createError("any.default", { error: defaultValue.error }, state, options));
            }
          } else {
            finalValue = Hoek.clone(this._flags.default);
          }
          if (errors2.length && typeof this._flags.error === "function") {
            const change = this._flags.error.call(this, errors2);
            if (typeof change === "string") {
              errors2 = [this.createOverrideError("override", { reason: errors2 }, state, options, change)];
            } else {
              errors2 = [].concat(change).map((err) => {
                return err instanceof Error ? err : this.createOverrideError(err.type || "override", err.context, state, options, err.message, err.template);
              });
            }
          }
          return {
            value: this._flags.strip ? void 0 : finalValue,
            finalValue,
            errors: errors2.length ? errors2 : null
          };
        };
        if (this._coerce) {
          const coerced = this._coerce.call(this, value, state, options);
          if (coerced.errors) {
            value = coerced.value;
            errors2 = errors2.concat(coerced.errors);
            return finish();
          }
          value = coerced.value;
        }
        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
          value = void 0;
        }
        const presence = this._flags.presence || options.presence;
        if (presence === "optional") {
          if (value === void 0) {
            const isDeepDefault = this._flags.hasOwnProperty("default") && this._flags.default === void 0;
            if (isDeepDefault && this._type === "object") {
              value = {};
            } else {
              return finish();
            }
          }
        } else if (presence === "required" && value === void 0) {
          errors2.push(this.createError("any.required", null, state, options));
          return finish();
        } else if (presence === "forbidden") {
          if (value === void 0) {
            return finish();
          }
          errors2.push(this.createError("any.unknown", null, state, options));
          return finish();
        }
        if (this._valids.has(value, state, options, this._flags.insensitive)) {
          return finish();
        }
        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
          errors2.push(this.createError(value === "" ? "any.empty" : "any.invalid", null, state, options));
          if (options.abortEarly || value === void 0) {
            return finish();
          }
        }
        if (this._base) {
          const base2 = this._base.call(this, value, state, options);
          if (base2.errors) {
            value = base2.value;
            errors2 = errors2.concat(base2.errors);
            return finish();
          }
          if (base2.value !== value) {
            value = base2.value;
            if (this._valids.has(value, state, options, this._flags.insensitive)) {
              return finish();
            }
            if (this._invalids.has(value, state, options, this._flags.insensitive)) {
              errors2.push(this.createError(value === "" ? "any.empty" : "any.invalid", null, state, options));
              if (options.abortEarly) {
                return finish();
              }
            }
          }
        }
        if (this._flags.allowOnly) {
          errors2.push(this.createError("any.allowOnly", { valids: this._valids.values({ stripUndefined: true }) }, state, options));
          if (options.abortEarly) {
            return finish();
          }
        }
        for (let i = 0; i < this._tests.length; ++i) {
          const test = this._tests[i];
          const ret = test.func.call(this, value, state, options);
          if (ret instanceof Errors.Err) {
            errors2.push(ret);
            if (options.abortEarly) {
              return finish();
            }
          } else {
            value = ret;
          }
        }
        return finish();
      }
      _validateWithOptions(value, options, callback) {
        if (options) {
          this.checkOptions(options);
        }
        const settings = internals.concatSettings(internals.defaults, options);
        const result = this._validate(value, null, settings);
        const errors2 = Errors.process(result.errors, value);
        if (callback) {
          return callback(errors2, result.value);
        }
        return {
          error: errors2,
          value: result.value,
          then(resolve, reject) {
            if (errors2) {
              return Promise.reject(errors2).catch(reject);
            }
            return Promise.resolve(result.value).then(resolve);
          },
          catch(reject) {
            if (errors2) {
              return Promise.reject(errors2).catch(reject);
            }
            return Promise.resolve(result.value);
          }
        };
      }
      validate(value, options, callback) {
        if (typeof options === "function") {
          return this._validateWithOptions(value, null, options);
        }
        return this._validateWithOptions(value, options, callback);
      }
      describe() {
        const description = {
          type: this._type
        };
        const flags = Object.keys(this._flags);
        if (flags.length) {
          if (["empty", "default", "lazy", "label"].some((flag) => this._flags.hasOwnProperty(flag))) {
            description.flags = {};
            for (let i = 0; i < flags.length; ++i) {
              const flag = flags[i];
              if (flag === "empty") {
                description.flags[flag] = this._flags[flag].describe();
              } else if (flag === "default") {
                if (Ref.isRef(this._flags[flag])) {
                  description.flags[flag] = this._flags[flag].toString();
                } else if (typeof this._flags[flag] === "function") {
                  description.flags[flag] = {
                    description: this._flags[flag].description,
                    function: this._flags[flag]
                  };
                } else {
                  description.flags[flag] = this._flags[flag];
                }
              } else if (flag === "lazy" || flag === "label") {
              } else {
                description.flags[flag] = this._flags[flag];
              }
            }
          } else {
            description.flags = this._flags;
          }
        }
        if (this._settings) {
          description.options = Hoek.clone(this._settings);
        }
        if (this._baseType) {
          description.base = this._baseType.describe();
        }
        if (this._description) {
          description.description = this._description;
        }
        if (this._notes.length) {
          description.notes = this._notes;
        }
        if (this._tags.length) {
          description.tags = this._tags;
        }
        if (this._meta.length) {
          description.meta = this._meta;
        }
        if (this._examples.length) {
          description.examples = this._examples;
        }
        if (this._unit) {
          description.unit = this._unit;
        }
        const valids = this._valids.values();
        if (valids.length) {
          description.valids = valids.map((v) => {
            return Ref.isRef(v) ? v.toString() : v;
          });
        }
        const invalids = this._invalids.values();
        if (invalids.length) {
          description.invalids = invalids.map((v) => {
            return Ref.isRef(v) ? v.toString() : v;
          });
        }
        description.rules = [];
        for (let i = 0; i < this._tests.length; ++i) {
          const validator = this._tests[i];
          const item = { name: validator.name };
          if (validator.arg !== void 0) {
            item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
          }
          const options = validator.options;
          if (options) {
            if (options.hasRef) {
              item.arg = {};
              const keys = Object.keys(validator.arg);
              for (let j = 0; j < keys.length; ++j) {
                const key = keys[j];
                const value = validator.arg[key];
                item.arg[key] = Ref.isRef(value) ? value.toString() : value;
              }
            }
            if (typeof options.description === "string") {
              item.description = options.description;
            } else if (typeof options.description === "function") {
              item.description = options.description(item.arg);
            }
          }
          description.rules.push(item);
        }
        if (!description.rules.length) {
          delete description.rules;
        }
        const label = this._getLabel();
        if (label) {
          description.label = label;
        }
        return description;
      }
      label(name) {
        Hoek.assert(name && typeof name === "string", "Label name must be a non-empty string");
        const obj = this.clone();
        obj._flags.label = name;
        return obj;
      }
      _getLabel(def) {
        return this._flags.label || def;
      }
    };
    internals.Any.prototype.isImmutable = true;
    internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
    internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
    internals.Any.prototype.exist = internals.Any.prototype.required;
    internals._try = function(fn, args) {
      let err;
      let result;
      try {
        result = fn.apply(null, args);
      } catch (e) {
        err = e;
      }
      return {
        value: result,
        error: err
      };
    };
    internals.concatSettings = function(target, source) {
      if (!target && !source) {
        return null;
      }
      const obj = Object.assign({}, target);
      if (source) {
        const sKeys = Object.keys(source);
        for (let i = 0; i < sKeys.length; ++i) {
          const key = sKeys[i];
          if (key !== "language" || !obj.hasOwnProperty(key)) {
            obj[key] = source[key];
          } else {
            obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
          }
        }
      }
      return obj;
    };
  }
});

// ../../../node_modules/joi/lib/types/alternatives/index.js
var require_alternatives = __commonJS({
  "../../../node_modules/joi/lib/types/alternatives/index.js"(exports, module) {
    var Hoek = require_lib();
    var Any = require_any();
    var Cast = require_cast();
    var Ref = require_ref();
    var internals = {};
    internals.Alternatives = class extends Any {
      constructor() {
        super();
        this._type = "alternatives";
        this._invalids.remove(null);
        this._inner.matches = [];
      }
      _base(value, state, options) {
        let errors2 = [];
        const il = this._inner.matches.length;
        const baseType = this._baseType;
        for (let i = 0; i < il; ++i) {
          const item = this._inner.matches[i];
          if (!item.schema) {
            const schema = item.peek || item.is;
            const input = item.is ? item.ref(state.reference || state.parent, options) : value;
            const failed = schema._validate(input, null, options, state.parent).errors;
            if (failed) {
              if (item.otherwise) {
                return item.otherwise._validate(value, state, options);
              }
            } else if (item.then) {
              return item.then._validate(value, state, options);
            }
            if (i === il - 1 && baseType) {
              return baseType._validate(value, state, options);
            }
            continue;
          }
          const result = item.schema._validate(value, state, options);
          if (!result.errors) {
            return result;
          }
          errors2 = errors2.concat(result.errors);
        }
        if (errors2.length) {
          return { errors: this.createError("alternatives.child", { reason: errors2 }, state, options) };
        }
        return { errors: this.createError("alternatives.base", null, state, options) };
      }
      try(...schemas) {
        schemas = Hoek.flatten(schemas);
        Hoek.assert(schemas.length, "Cannot add other alternatives without at least one schema");
        const obj = this.clone();
        for (let i = 0; i < schemas.length; ++i) {
          const cast = Cast.schema(this._currentJoi, schemas[i]);
          if (cast._refs.length) {
            obj._refs = obj._refs.concat(cast._refs);
          }
          obj._inner.matches.push({ schema: cast });
        }
        return obj;
      }
      when(condition, options) {
        let schemaCondition = false;
        Hoek.assert(Ref.isRef(condition) || typeof condition === "string" || (schemaCondition = condition instanceof Any), "Invalid condition:", condition);
        Hoek.assert(options, "Missing options");
        Hoek.assert(typeof options === "object", "Invalid options");
        if (schemaCondition) {
          Hoek.assert(!options.hasOwnProperty("is"), '"is" can not be used with a schema condition');
        } else {
          Hoek.assert(options.hasOwnProperty("is"), 'Missing "is" directive');
        }
        Hoek.assert(options.then !== void 0 || options.otherwise !== void 0, 'options must have at least one of "then" or "otherwise"');
        const obj = this.clone();
        let is;
        if (!schemaCondition) {
          is = Cast.schema(this._currentJoi, options.is);
          if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {
            is = is.required();
          }
        }
        const item = {
          ref: schemaCondition ? null : Cast.ref(condition),
          peek: schemaCondition ? condition : null,
          is,
          then: options.then !== void 0 ? Cast.schema(this._currentJoi, options.then) : void 0,
          otherwise: options.otherwise !== void 0 ? Cast.schema(this._currentJoi, options.otherwise) : void 0
        };
        if (obj._baseType) {
          item.then = item.then && obj._baseType.concat(item.then);
          item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
        }
        if (!schemaCondition) {
          Ref.push(obj._refs, item.ref);
          obj._refs = obj._refs.concat(item.is._refs);
        }
        if (item.then && item.then._refs) {
          obj._refs = obj._refs.concat(item.then._refs);
        }
        if (item.otherwise && item.otherwise._refs) {
          obj._refs = obj._refs.concat(item.otherwise._refs);
        }
        obj._inner.matches.push(item);
        return obj;
      }
      describe() {
        const description = Any.prototype.describe.call(this);
        const alternatives = [];
        for (let i = 0; i < this._inner.matches.length; ++i) {
          const item = this._inner.matches[i];
          if (item.schema) {
            alternatives.push(item.schema.describe());
          } else {
            const when = item.is ? {
              ref: item.ref.toString(),
              is: item.is.describe()
            } : {
              peek: item.peek.describe()
            };
            if (item.then) {
              when.then = item.then.describe();
            }
            if (item.otherwise) {
              when.otherwise = item.otherwise.describe();
            }
            alternatives.push(when);
          }
        }
        description.alternatives = alternatives;
        return description;
      }
    };
    module.exports = new internals.Alternatives();
  }
});
export default require_alternatives();
//# sourceMappingURL=joi_lib_types_alternatives_index__js.js.map
